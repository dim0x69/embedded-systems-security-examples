
P3_TZEN_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  08040000  08040000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002438  080401f8  080401f8  000101f8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08042630  08042630  00018010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08042630  08042630  00018010  2**0
                  CONTENTS
  4 .ARM          00000000  08042630  08042630  00018010  2**0
                  CONTENTS
  5 .preinit_array 00000000  08042630  08042630  00018010  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  08042630  08042630  00012630  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  08042638  08042638  00012638  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000010  20018000  08042640  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000000a0  20018010  08042650  00018010  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200180b0  08042650  000180b0  2**0
                  ALLOC
 11 .ARM.attributes 00000036  00000000  00000000  00018010  2**0
                  CONTENTS, READONLY
 12 .debug_info   00009baf  00000000  00000000  00018046  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000156a  00000000  00000000  00021bf5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000928  00000000  00000000  00023160  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000870  00000000  00000000  00023a88  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00028bea  00000000  00000000  000242f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00007ef5  00000000  00000000  0004cee2  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0010c564  00000000  00000000  00054dd7  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  0016133b  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000025e0  00000000  00000000  001613b8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080401f8 <__do_global_dtors_aux>:
 80401f8:	b510      	push	{r4, lr}
 80401fa:	4c05      	ldr	r4, [pc, #20]	; (8040210 <__do_global_dtors_aux+0x18>)
 80401fc:	7823      	ldrb	r3, [r4, #0]
 80401fe:	b933      	cbnz	r3, 804020e <__do_global_dtors_aux+0x16>
 8040200:	4b04      	ldr	r3, [pc, #16]	; (8040214 <__do_global_dtors_aux+0x1c>)
 8040202:	b113      	cbz	r3, 804020a <__do_global_dtors_aux+0x12>
 8040204:	4804      	ldr	r0, [pc, #16]	; (8040218 <__do_global_dtors_aux+0x20>)
 8040206:	e000      	b.n	804020a <__do_global_dtors_aux+0x12>
 8040208:	bf00      	nop
 804020a:	2301      	movs	r3, #1
 804020c:	7023      	strb	r3, [r4, #0]
 804020e:	bd10      	pop	{r4, pc}
 8040210:	20018010 	.word	0x20018010
 8040214:	00000000 	.word	0x00000000
 8040218:	080425e4 	.word	0x080425e4

0804021c <frame_dummy>:
 804021c:	b508      	push	{r3, lr}
 804021e:	4b03      	ldr	r3, [pc, #12]	; (804022c <frame_dummy+0x10>)
 8040220:	b11b      	cbz	r3, 804022a <frame_dummy+0xe>
 8040222:	4903      	ldr	r1, [pc, #12]	; (8040230 <frame_dummy+0x14>)
 8040224:	4803      	ldr	r0, [pc, #12]	; (8040234 <frame_dummy+0x18>)
 8040226:	e000      	b.n	804022a <frame_dummy+0xe>
 8040228:	bf00      	nop
 804022a:	bd08      	pop	{r3, pc}
 804022c:	00000000 	.word	0x00000000
 8040230:	20018014 	.word	0x20018014
 8040234:	080425e4 	.word	0x080425e4

08040238 <MX_RNG_Init>:

/* My RNG initializiation */
RNG_HandleTypeDef hrng;

static void MX_RNG_Init(void)
{
 8040238:	b580      	push	{r7, lr}
 804023a:	af00      	add	r7, sp, #0

  hrng.Instance = RNG;
 804023c:	4b07      	ldr	r3, [pc, #28]	; (804025c <MX_RNG_Init+0x24>)
 804023e:	4a08      	ldr	r2, [pc, #32]	; (8040260 <MX_RNG_Init+0x28>)
 8040240:	601a      	str	r2, [r3, #0]
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
 8040242:	4b06      	ldr	r3, [pc, #24]	; (804025c <MX_RNG_Init+0x24>)
 8040244:	2200      	movs	r2, #0
 8040246:	605a      	str	r2, [r3, #4]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 8040248:	4804      	ldr	r0, [pc, #16]	; (804025c <MX_RNG_Init+0x24>)
 804024a:	f002 f8bb 	bl	80423c4 <HAL_RNG_Init>
 804024e:	4603      	mov	r3, r0
 8040250:	2b00      	cmp	r3, #0
 8040252:	d001      	beq.n	8040258 <MX_RNG_Init+0x20>
  {
    Error_Handler();
 8040254:	f000 f8f0 	bl	8040438 <Error_Handler>
  }
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}
 8040258:	bf00      	nop
 804025a:	bd80      	pop	{r7, pc}
 804025c:	20018094 	.word	0x20018094
 8040260:	420c0800 	.word	0x420c0800

08040264 <NONSECURE_GenerateRandom>:

uint32_t NONSECURE_GenerateRandom(){
 8040264:	b580      	push	{r7, lr}
 8040266:	b082      	sub	sp, #8
 8040268:	af00      	add	r7, sp, #0
	MX_RNG_Init();
 804026a:	f7ff ffe5 	bl	8040238 <MX_RNG_Init>
 	uint32_t random32bit;
 	HAL_StatusTypeDef status = HAL_ERROR;
 804026e:	2301      	movs	r3, #1
 8040270:	71fb      	strb	r3, [r7, #7]
 	status = HAL_RNG_GenerateRandomNumber(&hrng, &random32bit);
 8040272:	463b      	mov	r3, r7
 8040274:	4619      	mov	r1, r3
 8040276:	4806      	ldr	r0, [pc, #24]	; (8040290 <NONSECURE_GenerateRandom+0x2c>)
 8040278:	f002 f938 	bl	80424ec <HAL_RNG_GenerateRandomNumber>
 804027c:	4603      	mov	r3, r0
 804027e:	71fb      	strb	r3, [r7, #7]
 	while (status == HAL_ERROR){}
 8040280:	79fb      	ldrb	r3, [r7, #7]
 8040282:	2b01      	cmp	r3, #1
 8040284:	d0fc      	beq.n	8040280 <NONSECURE_GenerateRandom+0x1c>
 	return random32bit;
 8040286:	683b      	ldr	r3, [r7, #0]
 }
 8040288:	4618      	mov	r0, r3
 804028a:	3708      	adds	r7, #8
 804028c:	46bd      	mov	sp, r7
 804028e:	bd80      	pop	{r7, pc}
 8040290:	20018094 	.word	0x20018094

08040294 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8040294:	b580      	push	{r7, lr}
 8040296:	b082      	sub	sp, #8
 8040298:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 804029a:	f000 f9aa 	bl	80405f2 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 804029e:	f000 f8a1 	bl	80403e4 <MX_GPIO_Init>
  MX_ADC1_Init();
 80402a2:	f000 f81d 	bl	80402e0 <MX_ADC1_Init>
  MX_RTC_Init();
 80402a6:	f000 f895 	bl	80403d4 <MX_RTC_Init>
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
	  uint32_t random32bit;
	  GPIO_PinState button = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);
 80402aa:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80402ae:	480b      	ldr	r0, [pc, #44]	; (80402dc <main+0x48>)
 80402b0:	f001 fb9c 	bl	80419ec <HAL_GPIO_ReadPin>
 80402b4:	4603      	mov	r3, r0
 80402b6:	70fb      	strb	r3, [r7, #3]
	  if(button)
 80402b8:	78fb      	ldrb	r3, [r7, #3]
 80402ba:	2b00      	cmp	r3, #0
 80402bc:	d003      	beq.n	80402c6 <main+0x32>
		  random32bit = NONSECURE_GenerateRandom();
 80402be:	f7ff ffd1 	bl	8040264 <NONSECURE_GenerateRandom>
 80402c2:	6078      	str	r0, [r7, #4]
 80402c4:	e002      	b.n	80402cc <main+0x38>
	  else
		  random32bit = SECURE_GenerateRandom();
 80402c6:	f002 f9a3 	bl	8042610 <__SECURE_GenerateRandom_veneer>
 80402ca:	6078      	str	r0, [r7, #4]
	  HAL_Delay(1000);
 80402cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80402d0:	f000 fa02 	bl	80406d8 <HAL_Delay>
	  SECURE_TransmitRandomUart(random32bit);
 80402d4:	6878      	ldr	r0, [r7, #4]
 80402d6:	f002 f9a3 	bl	8042620 <__SECURE_TransmitRandomUart_veneer>
  {
 80402da:	e7e6      	b.n	80402aa <main+0x16>
 80402dc:	42020800 	.word	0x42020800

080402e0 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
 80402e0:	b580      	push	{r7, lr}
 80402e2:	b08a      	sub	sp, #40	; 0x28
 80402e4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 80402e6:	f107 031c 	add.w	r3, r7, #28
 80402ea:	2200      	movs	r2, #0
 80402ec:	601a      	str	r2, [r3, #0]
 80402ee:	605a      	str	r2, [r3, #4]
 80402f0:	609a      	str	r2, [r3, #8]
  ADC_ChannelConfTypeDef sConfig = {0};
 80402f2:	1d3b      	adds	r3, r7, #4
 80402f4:	2200      	movs	r2, #0
 80402f6:	601a      	str	r2, [r3, #0]
 80402f8:	605a      	str	r2, [r3, #4]
 80402fa:	609a      	str	r2, [r3, #8]
 80402fc:	60da      	str	r2, [r3, #12]
 80402fe:	611a      	str	r2, [r3, #16]
 8040300:	615a      	str	r2, [r3, #20]
  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /** Common config 
  */
  hadc1.Instance = ADC1;
 8040302:	4b31      	ldr	r3, [pc, #196]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040304:	4a31      	ldr	r2, [pc, #196]	; (80403cc <MX_ADC1_Init+0xec>)
 8040306:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8040308:	4b2f      	ldr	r3, [pc, #188]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804030a:	2200      	movs	r2, #0
 804030c:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 804030e:	4b2e      	ldr	r3, [pc, #184]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040310:	2200      	movs	r2, #0
 8040312:	609a      	str	r2, [r3, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8040314:	4b2c      	ldr	r3, [pc, #176]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040316:	2200      	movs	r2, #0
 8040318:	60da      	str	r2, [r3, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 804031a:	4b2b      	ldr	r3, [pc, #172]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804031c:	2200      	movs	r2, #0
 804031e:	611a      	str	r2, [r3, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8040320:	4b29      	ldr	r3, [pc, #164]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040322:	2204      	movs	r2, #4
 8040324:	615a      	str	r2, [r3, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8040326:	4b28      	ldr	r3, [pc, #160]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040328:	2200      	movs	r2, #0
 804032a:	761a      	strb	r2, [r3, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 804032c:	4b26      	ldr	r3, [pc, #152]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804032e:	2200      	movs	r2, #0
 8040330:	765a      	strb	r2, [r3, #25]
  hadc1.Init.NbrOfConversion = 1;
 8040332:	4b25      	ldr	r3, [pc, #148]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040334:	2201      	movs	r2, #1
 8040336:	61da      	str	r2, [r3, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8040338:	4b23      	ldr	r3, [pc, #140]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804033a:	2200      	movs	r2, #0
 804033c:	f883 2020 	strb.w	r2, [r3, #32]
  hadc1.Init.NbrOfDiscConversion = 1;
 8040340:	4b21      	ldr	r3, [pc, #132]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040342:	2201      	movs	r2, #1
 8040344:	625a      	str	r2, [r3, #36]	; 0x24
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8040346:	4b20      	ldr	r3, [pc, #128]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040348:	2200      	movs	r2, #0
 804034a:	629a      	str	r2, [r3, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 804034c:	4b1e      	ldr	r3, [pc, #120]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804034e:	2200      	movs	r2, #0
 8040350:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8040352:	4b1d      	ldr	r3, [pc, #116]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040354:	2200      	movs	r2, #0
 8040356:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 804035a:	4b1b      	ldr	r3, [pc, #108]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804035c:	2200      	movs	r2, #0
 804035e:	635a      	str	r2, [r3, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 8040360:	4b19      	ldr	r3, [pc, #100]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040362:	2200      	movs	r2, #0
 8040364:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8040368:	4817      	ldr	r0, [pc, #92]	; (80403c8 <MX_ADC1_Init+0xe8>)
 804036a:	f000 fb69 	bl	8040a40 <HAL_ADC_Init>
 804036e:	4603      	mov	r3, r0
 8040370:	2b00      	cmp	r3, #0
 8040372:	d001      	beq.n	8040378 <MX_ADC1_Init+0x98>
  {
    Error_Handler();
 8040374:	f000 f860 	bl	8040438 <Error_Handler>
  }
  /** Configure the ADC multi-mode 
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8040378:	2300      	movs	r3, #0
 804037a:	61fb      	str	r3, [r7, #28]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 804037c:	f107 031c 	add.w	r3, r7, #28
 8040380:	4619      	mov	r1, r3
 8040382:	4811      	ldr	r0, [pc, #68]	; (80403c8 <MX_ADC1_Init+0xe8>)
 8040384:	f001 f82e 	bl	80413e4 <HAL_ADCEx_MultiModeConfigChannel>
 8040388:	4603      	mov	r3, r0
 804038a:	2b00      	cmp	r3, #0
 804038c:	d001      	beq.n	8040392 <MX_ADC1_Init+0xb2>
  {
    Error_Handler();
 804038e:	f000 f853 	bl	8040438 <Error_Handler>
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_3;
 8040392:	4b0f      	ldr	r3, [pc, #60]	; (80403d0 <MX_ADC1_Init+0xf0>)
 8040394:	607b      	str	r3, [r7, #4]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8040396:	2306      	movs	r3, #6
 8040398:	60bb      	str	r3, [r7, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 804039a:	2300      	movs	r3, #0
 804039c:	60fb      	str	r3, [r7, #12]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 804039e:	237f      	movs	r3, #127	; 0x7f
 80403a0:	613b      	str	r3, [r7, #16]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 80403a2:	2304      	movs	r3, #4
 80403a4:	617b      	str	r3, [r7, #20]
  sConfig.Offset = 0;
 80403a6:	2300      	movs	r3, #0
 80403a8:	61bb      	str	r3, [r7, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80403aa:	1d3b      	adds	r3, r7, #4
 80403ac:	4619      	mov	r1, r3
 80403ae:	4806      	ldr	r0, [pc, #24]	; (80403c8 <MX_ADC1_Init+0xe8>)
 80403b0:	f000 fc96 	bl	8040ce0 <HAL_ADC_ConfigChannel>
 80403b4:	4603      	mov	r3, r0
 80403b6:	2b00      	cmp	r3, #0
 80403b8:	d001      	beq.n	80403be <MX_ADC1_Init+0xde>
  {
    Error_Handler();
 80403ba:	f000 f83d 	bl	8040438 <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 80403be:	bf00      	nop
 80403c0:	3728      	adds	r7, #40	; 0x28
 80403c2:	46bd      	mov	sp, r7
 80403c4:	bd80      	pop	{r7, pc}
 80403c6:	bf00      	nop
 80403c8:	2001802c 	.word	0x2001802c
 80403cc:	42028000 	.word	0x42028000
 80403d0:	0c900008 	.word	0x0c900008

080403d4 <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 80403d4:	b480      	push	{r7}
 80403d6:	af00      	add	r7, sp, #0
  /* USER CODE END RTC_Init 1 */
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 80403d8:	bf00      	nop
 80403da:	46bd      	mov	sp, r7
 80403dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80403e0:	4770      	bx	lr
	...

080403e4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80403e4:	b580      	push	{r7, lr}
 80403e6:	b086      	sub	sp, #24
 80403e8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80403ea:	1d3b      	adds	r3, r7, #4
 80403ec:	2200      	movs	r2, #0
 80403ee:	601a      	str	r2, [r3, #0]
 80403f0:	605a      	str	r2, [r3, #4]
 80403f2:	609a      	str	r2, [r3, #8]
 80403f4:	60da      	str	r2, [r3, #12]
 80403f6:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80403f8:	4b0d      	ldr	r3, [pc, #52]	; (8040430 <MX_GPIO_Init+0x4c>)
 80403fa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80403fc:	4a0c      	ldr	r2, [pc, #48]	; (8040430 <MX_GPIO_Init+0x4c>)
 80403fe:	f043 0304 	orr.w	r3, r3, #4
 8040402:	64d3      	str	r3, [r2, #76]	; 0x4c
 8040404:	4b0a      	ldr	r3, [pc, #40]	; (8040430 <MX_GPIO_Init+0x4c>)
 8040406:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8040408:	f003 0304 	and.w	r3, r3, #4
 804040c:	603b      	str	r3, [r7, #0]
 804040e:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin : PC13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8040410:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8040414:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8040416:	2300      	movs	r3, #0
 8040418:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 804041a:	2300      	movs	r3, #0
 804041c:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 804041e:	1d3b      	adds	r3, r7, #4
 8040420:	4619      	mov	r1, r3
 8040422:	4804      	ldr	r0, [pc, #16]	; (8040434 <MX_GPIO_Init+0x50>)
 8040424:	f001 f962 	bl	80416ec <HAL_GPIO_Init>

}
 8040428:	bf00      	nop
 804042a:	3718      	adds	r7, #24
 804042c:	46bd      	mov	sp, r7
 804042e:	bd80      	pop	{r7, pc}
 8040430:	40021000 	.word	0x40021000
 8040434:	42020800 	.word	0x42020800

08040438 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8040438:	b480      	push	{r7}
 804043a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 804043c:	bf00      	nop
 804043e:	46bd      	mov	sp, r7
 8040440:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040444:	4770      	bx	lr
	...

08040448 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8040448:	b480      	push	{r7}
 804044a:	b083      	sub	sp, #12
 804044c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 804044e:	4b0f      	ldr	r3, [pc, #60]	; (804048c <HAL_MspInit+0x44>)
 8040450:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8040452:	4a0e      	ldr	r2, [pc, #56]	; (804048c <HAL_MspInit+0x44>)
 8040454:	f043 0301 	orr.w	r3, r3, #1
 8040458:	6613      	str	r3, [r2, #96]	; 0x60
 804045a:	4b0c      	ldr	r3, [pc, #48]	; (804048c <HAL_MspInit+0x44>)
 804045c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 804045e:	f003 0301 	and.w	r3, r3, #1
 8040462:	607b      	str	r3, [r7, #4]
 8040464:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 8040466:	4b09      	ldr	r3, [pc, #36]	; (804048c <HAL_MspInit+0x44>)
 8040468:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 804046a:	4a08      	ldr	r2, [pc, #32]	; (804048c <HAL_MspInit+0x44>)
 804046c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8040470:	6593      	str	r3, [r2, #88]	; 0x58
 8040472:	4b06      	ldr	r3, [pc, #24]	; (804048c <HAL_MspInit+0x44>)
 8040474:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040476:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 804047a:	603b      	str	r3, [r7, #0]
 804047c:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 804047e:	bf00      	nop
 8040480:	370c      	adds	r7, #12
 8040482:	46bd      	mov	sp, r7
 8040484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040488:	4770      	bx	lr
 804048a:	bf00      	nop
 804048c:	40021000 	.word	0x40021000

08040490 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8040490:	b580      	push	{r7, lr}
 8040492:	b0ae      	sub	sp, #184	; 0xb8
 8040494:	af00      	add	r7, sp, #0
 8040496:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8040498:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
 804049c:	2200      	movs	r2, #0
 804049e:	601a      	str	r2, [r3, #0]
 80404a0:	605a      	str	r2, [r3, #4]
 80404a2:	609a      	str	r2, [r3, #8]
 80404a4:	60da      	str	r2, [r3, #12]
 80404a6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80404a8:	f107 0310 	add.w	r3, r7, #16
 80404ac:	2294      	movs	r2, #148	; 0x94
 80404ae:	2100      	movs	r1, #0
 80404b0:	4618      	mov	r0, r3
 80404b2:	f002 f88f 	bl	80425d4 <memset>
  if(hadc->Instance==ADC1)
 80404b6:	687b      	ldr	r3, [r7, #4]
 80404b8:	681b      	ldr	r3, [r3, #0]
 80404ba:	4a1f      	ldr	r2, [pc, #124]	; (8040538 <HAL_ADC_MspInit+0xa8>)
 80404bc:	4293      	cmp	r3, r2
 80404be:	d137      	bne.n	8040530 <HAL_ADC_MspInit+0xa0>
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
  /** Initializes the peripherals clock 
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 80404c0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80404c4:	613b      	str	r3, [r7, #16]
    PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_SYSCLK;
 80404c6:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 80404ca:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80404ce:	f107 0310 	add.w	r3, r7, #16
 80404d2:	4618      	mov	r0, r3
 80404d4:	f001 faa2 	bl	8041a1c <HAL_RCCEx_PeriphCLKConfig>
 80404d8:	4603      	mov	r3, r0
 80404da:	2b00      	cmp	r3, #0
 80404dc:	d001      	beq.n	80404e2 <HAL_ADC_MspInit+0x52>
    {
      Error_Handler();
 80404de:	f7ff ffab 	bl	8040438 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 80404e2:	4b16      	ldr	r3, [pc, #88]	; (804053c <HAL_ADC_MspInit+0xac>)
 80404e4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80404e6:	4a15      	ldr	r2, [pc, #84]	; (804053c <HAL_ADC_MspInit+0xac>)
 80404e8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80404ec:	64d3      	str	r3, [r2, #76]	; 0x4c
 80404ee:	4b13      	ldr	r3, [pc, #76]	; (804053c <HAL_ADC_MspInit+0xac>)
 80404f0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80404f2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80404f6:	60fb      	str	r3, [r7, #12]
 80404f8:	68fb      	ldr	r3, [r7, #12]
  
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80404fa:	4b10      	ldr	r3, [pc, #64]	; (804053c <HAL_ADC_MspInit+0xac>)
 80404fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80404fe:	4a0f      	ldr	r2, [pc, #60]	; (804053c <HAL_ADC_MspInit+0xac>)
 8040500:	f043 0304 	orr.w	r3, r3, #4
 8040504:	64d3      	str	r3, [r2, #76]	; 0x4c
 8040506:	4b0d      	ldr	r3, [pc, #52]	; (804053c <HAL_ADC_MspInit+0xac>)
 8040508:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 804050a:	f003 0304 	and.w	r3, r3, #4
 804050e:	60bb      	str	r3, [r7, #8]
 8040510:	68bb      	ldr	r3, [r7, #8]
    /**ADC1 GPIO Configuration    
    PC2     ------> ADC1_IN3 
    */
    GPIO_InitStruct.Pin = VBUS_SENSE_Pin;
 8040512:	2304      	movs	r3, #4
 8040514:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8040518:	2303      	movs	r3, #3
 804051a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804051e:	2300      	movs	r3, #0
 8040520:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    HAL_GPIO_Init(VBUS_SENSE_GPIO_Port, &GPIO_InitStruct);
 8040524:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
 8040528:	4619      	mov	r1, r3
 804052a:	4805      	ldr	r0, [pc, #20]	; (8040540 <HAL_ADC_MspInit+0xb0>)
 804052c:	f001 f8de 	bl	80416ec <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 8040530:	bf00      	nop
 8040532:	37b8      	adds	r7, #184	; 0xb8
 8040534:	46bd      	mov	sp, r7
 8040536:	bd80      	pop	{r7, pc}
 8040538:	42028000 	.word	0x42028000
 804053c:	40021000 	.word	0x40021000
 8040540:	42020800 	.word	0x42020800

08040544 <MemManage_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8040544:	b480      	push	{r7}
 8040546:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8040548:	e7fe      	b.n	8040548 <MemManage_Handler+0x4>

0804054a <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 804054a:	b480      	push	{r7}
 804054c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 804054e:	e7fe      	b.n	804054e <UsageFault_Handler+0x4>

08040550 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8040550:	b480      	push	{r7}
 8040552:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8040554:	bf00      	nop
 8040556:	46bd      	mov	sp, r7
 8040558:	f85d 7b04 	ldr.w	r7, [sp], #4
 804055c:	4770      	bx	lr

0804055e <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 804055e:	b480      	push	{r7}
 8040560:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8040562:	bf00      	nop
 8040564:	46bd      	mov	sp, r7
 8040566:	f85d 7b04 	ldr.w	r7, [sp], #4
 804056a:	4770      	bx	lr

0804056c <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 804056c:	b580      	push	{r7, lr}
 804056e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8040570:	f000 f894 	bl	804069c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8040574:	bf00      	nop
 8040576:	bd80      	pop	{r7, pc}

08040578 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
 8040578:	b480      	push	{r7}
 804057a:	af00      	add	r7, sp, #0
#endif

  /* Non-secure main application shall call SystemCoreClockUpdate() to update */
  /* the SystemCoreClock variable to insure non-secure application relies on  */
  /* the initial clock reference set by secure application.                   */
}
 804057c:	bf00      	nop
 804057e:	46bd      	mov	sp, r7
 8040580:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040584:	4770      	bx	lr
	...

08040588 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 8040588:	b580      	push	{r7, lr}
 804058a:	af00      	add	r7, sp, #0
  /* Get the SystemCoreClock value from the secure domain */
  SystemCoreClock = SECURE_SystemCoreClockUpdate();
 804058c:	f002 f838 	bl	8042600 <__SECURE_SystemCoreClockUpdate_veneer>
 8040590:	4602      	mov	r2, r0
 8040592:	4b02      	ldr	r3, [pc, #8]	; (804059c <SystemCoreClockUpdate+0x14>)
 8040594:	601a      	str	r2, [r3, #0]
}
 8040596:	bf00      	nop
 8040598:	bd80      	pop	{r7, pc}
 804059a:	bf00      	nop
 804059c:	20018000 	.word	0x20018000

080405a0 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* set stack pointer */
 80405a0:	f8df d034 	ldr.w	sp, [pc, #52]	; 80405d8 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80405a4:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80405a6:	e003      	b.n	80405b0 <LoopCopyDataInit>

080405a8 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80405a8:	4b0c      	ldr	r3, [pc, #48]	; (80405dc <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 80405aa:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80405ac:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80405ae:	3104      	adds	r1, #4

080405b0 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80405b0:	480b      	ldr	r0, [pc, #44]	; (80405e0 <LoopForever+0xa>)
	ldr	r3, =_edata
 80405b2:	4b0c      	ldr	r3, [pc, #48]	; (80405e4 <LoopForever+0xe>)
	adds	r2, r0, r1
 80405b4:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80405b6:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80405b8:	d3f6      	bcc.n	80405a8 <CopyDataInit>
	ldr	r2, =_sbss
 80405ba:	4a0b      	ldr	r2, [pc, #44]	; (80405e8 <LoopForever+0x12>)
	b	LoopFillZerobss
 80405bc:	e002      	b.n	80405c4 <LoopFillZerobss>

080405be <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80405be:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80405c0:	f842 3b04 	str.w	r3, [r2], #4

080405c4 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80405c4:	4b09      	ldr	r3, [pc, #36]	; (80405ec <LoopForever+0x16>)
	cmp	r2, r3
 80405c6:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80405c8:	d3f9      	bcc.n	80405be <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80405ca:	f7ff ffd5 	bl	8040578 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80405ce:	f001 ffdd 	bl	804258c <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80405d2:	f7ff fe5f 	bl	8040294 <main>

080405d6 <LoopForever>:

LoopForever:
    b LoopForever
 80405d6:	e7fe      	b.n	80405d6 <LoopForever>
  ldr   sp, =_estack    /* set stack pointer */
 80405d8:	20030000 	.word	0x20030000
	ldr	r3, =_sidata
 80405dc:	08042640 	.word	0x08042640
	ldr	r0, =_sdata
 80405e0:	20018000 	.word	0x20018000
	ldr	r3, =_edata
 80405e4:	20018010 	.word	0x20018010
	ldr	r2, =_sbss
 80405e8:	20018010 	.word	0x20018010
	ldr	r3, = _ebss
 80405ec:	200180b0 	.word	0x200180b0

080405f0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80405f0:	e7fe      	b.n	80405f0 <ADC1_2_IRQHandler>

080405f2 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80405f2:	b580      	push	{r7, lr}
 80405f4:	b082      	sub	sp, #8
 80405f6:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80405f8:	2300      	movs	r3, #0
 80405fa:	71fb      	strb	r3, [r7, #7]

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 80405fc:	2004      	movs	r0, #4
 80405fe:	f001 f843 	bl	8041688 <HAL_NVIC_SetPriorityGrouping>

  /* Insure time base clock coherency */
  SystemCoreClockUpdate();
 8040602:	f7ff ffc1 	bl	8040588 <SystemCoreClockUpdate>
  
  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8040606:	2000      	movs	r0, #0
 8040608:	f000 f80e 	bl	8040628 <HAL_InitTick>
 804060c:	4603      	mov	r3, r0
 804060e:	2b00      	cmp	r3, #0
 8040610:	d002      	beq.n	8040618 <HAL_Init+0x26>
  {
    status = HAL_ERROR;
 8040612:	2301      	movs	r3, #1
 8040614:	71fb      	strb	r3, [r7, #7]
 8040616:	e001      	b.n	804061c <HAL_Init+0x2a>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 8040618:	f7ff ff16 	bl	8040448 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 804061c:	79fb      	ldrb	r3, [r7, #7]
}
 804061e:	4618      	mov	r0, r3
 8040620:	3708      	adds	r7, #8
 8040622:	46bd      	mov	sp, r7
 8040624:	bd80      	pop	{r7, pc}
	...

08040628 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8040628:	b580      	push	{r7, lr}
 804062a:	b084      	sub	sp, #16
 804062c:	af00      	add	r7, sp, #0
 804062e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 8040630:	2300      	movs	r3, #0
 8040632:	73fb      	strb	r3, [r7, #15]

  if (uwTickFreq != 0U)
 8040634:	4b16      	ldr	r3, [pc, #88]	; (8040690 <HAL_InitTick+0x68>)
 8040636:	681b      	ldr	r3, [r3, #0]
 8040638:	2b00      	cmp	r3, #0
 804063a:	d022      	beq.n	8040682 <HAL_InitTick+0x5a>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 804063c:	4b15      	ldr	r3, [pc, #84]	; (8040694 <HAL_InitTick+0x6c>)
 804063e:	681a      	ldr	r2, [r3, #0]
 8040640:	4b13      	ldr	r3, [pc, #76]	; (8040690 <HAL_InitTick+0x68>)
 8040642:	681b      	ldr	r3, [r3, #0]
 8040644:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8040648:	fbb1 f3f3 	udiv	r3, r1, r3
 804064c:	fbb2 f3f3 	udiv	r3, r2, r3
 8040650:	4618      	mov	r0, r3
 8040652:	f001 f83e 	bl	80416d2 <HAL_SYSTICK_Config>
 8040656:	4603      	mov	r3, r0
 8040658:	2b00      	cmp	r3, #0
 804065a:	d10f      	bne.n	804067c <HAL_InitTick+0x54>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 804065c:	687b      	ldr	r3, [r7, #4]
 804065e:	2b07      	cmp	r3, #7
 8040660:	d809      	bhi.n	8040676 <HAL_InitTick+0x4e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8040662:	2200      	movs	r2, #0
 8040664:	6879      	ldr	r1, [r7, #4]
 8040666:	f04f 30ff 	mov.w	r0, #4294967295
 804066a:	f001 f818 	bl	804169e <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 804066e:	4a0a      	ldr	r2, [pc, #40]	; (8040698 <HAL_InitTick+0x70>)
 8040670:	687b      	ldr	r3, [r7, #4]
 8040672:	6013      	str	r3, [r2, #0]
 8040674:	e007      	b.n	8040686 <HAL_InitTick+0x5e>
      }
      else
      {
        status = HAL_ERROR;
 8040676:	2301      	movs	r3, #1
 8040678:	73fb      	strb	r3, [r7, #15]
 804067a:	e004      	b.n	8040686 <HAL_InitTick+0x5e>
      }
    }
    else
    {
      status = HAL_ERROR;
 804067c:	2301      	movs	r3, #1
 804067e:	73fb      	strb	r3, [r7, #15]
 8040680:	e001      	b.n	8040686 <HAL_InitTick+0x5e>
    }
  }
  else
  {
    status = HAL_ERROR;
 8040682:	2301      	movs	r3, #1
 8040684:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 8040686:	7bfb      	ldrb	r3, [r7, #15]
}
 8040688:	4618      	mov	r0, r3
 804068a:	3710      	adds	r7, #16
 804068c:	46bd      	mov	sp, r7
 804068e:	bd80      	pop	{r7, pc}
 8040690:	20018008 	.word	0x20018008
 8040694:	20018000 	.word	0x20018000
 8040698:	20018004 	.word	0x20018004

0804069c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 804069c:	b480      	push	{r7}
 804069e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 80406a0:	4b05      	ldr	r3, [pc, #20]	; (80406b8 <HAL_IncTick+0x1c>)
 80406a2:	681a      	ldr	r2, [r3, #0]
 80406a4:	4b05      	ldr	r3, [pc, #20]	; (80406bc <HAL_IncTick+0x20>)
 80406a6:	681b      	ldr	r3, [r3, #0]
 80406a8:	4413      	add	r3, r2
 80406aa:	4a03      	ldr	r2, [pc, #12]	; (80406b8 <HAL_IncTick+0x1c>)
 80406ac:	6013      	str	r3, [r2, #0]
}
 80406ae:	bf00      	nop
 80406b0:	46bd      	mov	sp, r7
 80406b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80406b6:	4770      	bx	lr
 80406b8:	200180a8 	.word	0x200180a8
 80406bc:	20018008 	.word	0x20018008

080406c0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80406c0:	b480      	push	{r7}
 80406c2:	af00      	add	r7, sp, #0
  return uwTick;
 80406c4:	4b03      	ldr	r3, [pc, #12]	; (80406d4 <HAL_GetTick+0x14>)
 80406c6:	681b      	ldr	r3, [r3, #0]
}
 80406c8:	4618      	mov	r0, r3
 80406ca:	46bd      	mov	sp, r7
 80406cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80406d0:	4770      	bx	lr
 80406d2:	bf00      	nop
 80406d4:	200180a8 	.word	0x200180a8

080406d8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80406d8:	b580      	push	{r7, lr}
 80406da:	b084      	sub	sp, #16
 80406dc:	af00      	add	r7, sp, #0
 80406de:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 80406e0:	f7ff ffee 	bl	80406c0 <HAL_GetTick>
 80406e4:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 80406e6:	687b      	ldr	r3, [r7, #4]
 80406e8:	60fb      	str	r3, [r7, #12]

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 80406ea:	68fb      	ldr	r3, [r7, #12]
 80406ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 80406f0:	d004      	beq.n	80406fc <HAL_Delay+0x24>
  {
    wait += (uint32_t)(uwTickFreq);
 80406f2:	4b09      	ldr	r3, [pc, #36]	; (8040718 <HAL_Delay+0x40>)
 80406f4:	681b      	ldr	r3, [r3, #0]
 80406f6:	68fa      	ldr	r2, [r7, #12]
 80406f8:	4413      	add	r3, r2
 80406fa:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 80406fc:	bf00      	nop
 80406fe:	f7ff ffdf 	bl	80406c0 <HAL_GetTick>
 8040702:	4602      	mov	r2, r0
 8040704:	68bb      	ldr	r3, [r7, #8]
 8040706:	1ad3      	subs	r3, r2, r3
 8040708:	68fa      	ldr	r2, [r7, #12]
 804070a:	429a      	cmp	r2, r3
 804070c:	d8f7      	bhi.n	80406fe <HAL_Delay+0x26>
  {
  }
}
 804070e:	bf00      	nop
 8040710:	3710      	adds	r7, #16
 8040712:	46bd      	mov	sp, r7
 8040714:	bd80      	pop	{r7, pc}
 8040716:	bf00      	nop
 8040718:	20018008 	.word	0x20018008

0804071c <LL_ADC_SetCommonClock>:
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 804071c:	b480      	push	{r7}
 804071e:	b083      	sub	sp, #12
 8040720:	af00      	add	r7, sp, #0
 8040722:	6078      	str	r0, [r7, #4]
 8040724:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8040726:	687b      	ldr	r3, [r7, #4]
 8040728:	689b      	ldr	r3, [r3, #8]
 804072a:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 804072e:	683b      	ldr	r3, [r7, #0]
 8040730:	431a      	orrs	r2, r3
 8040732:	687b      	ldr	r3, [r7, #4]
 8040734:	609a      	str	r2, [r3, #8]
}
 8040736:	bf00      	nop
 8040738:	370c      	adds	r7, #12
 804073a:	46bd      	mov	sp, r7
 804073c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040740:	4770      	bx	lr

08040742 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 8040742:	b480      	push	{r7}
 8040744:	b083      	sub	sp, #12
 8040746:	af00      	add	r7, sp, #0
 8040748:	6078      	str	r0, [r7, #4]
 804074a:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 804074c:	687b      	ldr	r3, [r7, #4]
 804074e:	689b      	ldr	r3, [r3, #8]
 8040750:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 8040754:	683b      	ldr	r3, [r7, #0]
 8040756:	431a      	orrs	r2, r3
 8040758:	687b      	ldr	r3, [r7, #4]
 804075a:	609a      	str	r2, [r3, #8]
}
 804075c:	bf00      	nop
 804075e:	370c      	adds	r7, #12
 8040760:	46bd      	mov	sp, r7
 8040762:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040766:	4770      	bx	lr

08040768 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
{
 8040768:	b480      	push	{r7}
 804076a:	b083      	sub	sp, #12
 804076c:	af00      	add	r7, sp, #0
 804076e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8040770:	687b      	ldr	r3, [r7, #4]
 8040772:	689b      	ldr	r3, [r3, #8]
 8040774:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 8040778:	4618      	mov	r0, r3
 804077a:	370c      	adds	r7, #12
 804077c:	46bd      	mov	sp, r7
 804077e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040782:	4770      	bx	lr

08040784 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 8040784:	b490      	push	{r4, r7}
 8040786:	b084      	sub	sp, #16
 8040788:	af00      	add	r7, sp, #0
 804078a:	60f8      	str	r0, [r7, #12]
 804078c:	60b9      	str	r1, [r7, #8]
 804078e:	607a      	str	r2, [r7, #4]
 8040790:	603b      	str	r3, [r7, #0]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8040792:	68fb      	ldr	r3, [r7, #12]
 8040794:	3360      	adds	r3, #96	; 0x60
 8040796:	461a      	mov	r2, r3
 8040798:	68bb      	ldr	r3, [r7, #8]
 804079a:	009b      	lsls	r3, r3, #2
 804079c:	4413      	add	r3, r2
 804079e:	461c      	mov	r4, r3

  MODIFY_REG(*preg,
 80407a0:	6822      	ldr	r2, [r4, #0]
 80407a2:	4b08      	ldr	r3, [pc, #32]	; (80407c4 <LL_ADC_SetOffset+0x40>)
 80407a4:	4013      	ands	r3, r2
 80407a6:	687a      	ldr	r2, [r7, #4]
 80407a8:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 80407ac:	683a      	ldr	r2, [r7, #0]
 80407ae:	430a      	orrs	r2, r1
 80407b0:	4313      	orrs	r3, r2
 80407b2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80407b6:	6023      	str	r3, [r4, #0]
             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
}
 80407b8:	bf00      	nop
 80407ba:	3710      	adds	r7, #16
 80407bc:	46bd      	mov	sp, r7
 80407be:	bc90      	pop	{r4, r7}
 80407c0:	4770      	bx	lr
 80407c2:	bf00      	nop
 80407c4:	03fff000 	.word	0x03fff000

080407c8 <LL_ADC_GetOffsetChannel>:
  *         (1, 2, 3, 4) For ADC channel read back from ADC register,
  *                      comparison with internal channel parameter to be done
  *                      using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety)
{
 80407c8:	b490      	push	{r4, r7}
 80407ca:	b082      	sub	sp, #8
 80407cc:	af00      	add	r7, sp, #0
 80407ce:	6078      	str	r0, [r7, #4]
 80407d0:	6039      	str	r1, [r7, #0]
  register const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80407d2:	687b      	ldr	r3, [r7, #4]
 80407d4:	3360      	adds	r3, #96	; 0x60
 80407d6:	461a      	mov	r2, r3
 80407d8:	683b      	ldr	r3, [r7, #0]
 80407da:	009b      	lsls	r3, r3, #2
 80407dc:	4413      	add	r3, r2
 80407de:	461c      	mov	r4, r3

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80407e0:	6823      	ldr	r3, [r4, #0]
 80407e2:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 80407e6:	4618      	mov	r0, r3
 80407e8:	3708      	adds	r7, #8
 80407ea:	46bd      	mov	sp, r7
 80407ec:	bc90      	pop	{r4, r7}
 80407ee:	4770      	bx	lr

080407f0 <LL_ADC_SetOffsetState>:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
{
 80407f0:	b490      	push	{r4, r7}
 80407f2:	b084      	sub	sp, #16
 80407f4:	af00      	add	r7, sp, #0
 80407f6:	60f8      	str	r0, [r7, #12]
 80407f8:	60b9      	str	r1, [r7, #8]
 80407fa:	607a      	str	r2, [r7, #4]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80407fc:	68fb      	ldr	r3, [r7, #12]
 80407fe:	3360      	adds	r3, #96	; 0x60
 8040800:	461a      	mov	r2, r3
 8040802:	68bb      	ldr	r3, [r7, #8]
 8040804:	009b      	lsls	r3, r3, #2
 8040806:	4413      	add	r3, r2
 8040808:	461c      	mov	r4, r3

  MODIFY_REG(*preg,
 804080a:	6823      	ldr	r3, [r4, #0]
 804080c:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8040810:	687b      	ldr	r3, [r7, #4]
 8040812:	4313      	orrs	r3, r2
 8040814:	6023      	str	r3, [r4, #0]
             ADC_OFR1_OFFSET1_EN,
             OffsetState);
}
 8040816:	bf00      	nop
 8040818:	3710      	adds	r7, #16
 804081a:	46bd      	mov	sp, r7
 804081c:	bc90      	pop	{r4, r7}
 804081e:	4770      	bx	lr

08040820 <LL_ADC_SetSamplingTimeCommonConfig>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_DEFAULT
  *         @arg @ref LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetSamplingTimeCommonConfig(ADC_TypeDef *ADCx, uint32_t SamplingTimeCommonConfig)
{
 8040820:	b480      	push	{r7}
 8040822:	b083      	sub	sp, #12
 8040824:	af00      	add	r7, sp, #0
 8040826:	6078      	str	r0, [r7, #4]
 8040828:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 804082a:	687b      	ldr	r3, [r7, #4]
 804082c:	695b      	ldr	r3, [r3, #20]
 804082e:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8040832:	683b      	ldr	r3, [r7, #0]
 8040834:	431a      	orrs	r2, r3
 8040836:	687b      	ldr	r3, [r7, #4]
 8040838:	615a      	str	r2, [r3, #20]
}
 804083a:	bf00      	nop
 804083c:	370c      	adds	r7, #12
 804083e:	46bd      	mov	sp, r7
 8040840:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040844:	4770      	bx	lr

08040846 <LL_ADC_REG_SetSequencerRanks>:
  *         (7) On STM32L5, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 8040846:	b490      	push	{r4, r7}
 8040848:	b084      	sub	sp, #16
 804084a:	af00      	add	r7, sp, #0
 804084c:	60f8      	str	r0, [r7, #12]
 804084e:	60b9      	str	r1, [r7, #8]
 8040850:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8040852:	68fb      	ldr	r3, [r7, #12]
 8040854:	3330      	adds	r3, #48	; 0x30
 8040856:	461a      	mov	r2, r3
 8040858:	68bb      	ldr	r3, [r7, #8]
 804085a:	0a1b      	lsrs	r3, r3, #8
 804085c:	009b      	lsls	r3, r3, #2
 804085e:	f003 030c 	and.w	r3, r3, #12
 8040862:	4413      	add	r3, r2
 8040864:	461c      	mov	r4, r3

  MODIFY_REG(*preg,
 8040866:	6822      	ldr	r2, [r4, #0]
 8040868:	68bb      	ldr	r3, [r7, #8]
 804086a:	f003 031f 	and.w	r3, r3, #31
 804086e:	211f      	movs	r1, #31
 8040870:	fa01 f303 	lsl.w	r3, r1, r3
 8040874:	43db      	mvns	r3, r3
 8040876:	401a      	ands	r2, r3
 8040878:	687b      	ldr	r3, [r7, #4]
 804087a:	0e9b      	lsrs	r3, r3, #26
 804087c:	f003 011f 	and.w	r1, r3, #31
 8040880:	68bb      	ldr	r3, [r7, #8]
 8040882:	f003 031f 	and.w	r3, r3, #31
 8040886:	fa01 f303 	lsl.w	r3, r1, r3
 804088a:	4313      	orrs	r3, r2
 804088c:	6023      	str	r3, [r4, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
 804088e:	bf00      	nop
 8040890:	3710      	adds	r7, #16
 8040892:	46bd      	mov	sp, r7
 8040894:	bc90      	pop	{r4, r7}
 8040896:	4770      	bx	lr

08040898 <LL_ADC_SetChannelSamplingTime>:
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 8040898:	b490      	push	{r4, r7}
 804089a:	b084      	sub	sp, #16
 804089c:	af00      	add	r7, sp, #0
 804089e:	60f8      	str	r0, [r7, #12]
 80408a0:	60b9      	str	r1, [r7, #8]
 80408a2:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80408a4:	68fb      	ldr	r3, [r7, #12]
 80408a6:	3314      	adds	r3, #20
 80408a8:	461a      	mov	r2, r3
 80408aa:	68bb      	ldr	r3, [r7, #8]
 80408ac:	0e5b      	lsrs	r3, r3, #25
 80408ae:	009b      	lsls	r3, r3, #2
 80408b0:	f003 0304 	and.w	r3, r3, #4
 80408b4:	4413      	add	r3, r2
 80408b6:	461c      	mov	r4, r3

  MODIFY_REG(*preg,
 80408b8:	6822      	ldr	r2, [r4, #0]
 80408ba:	68bb      	ldr	r3, [r7, #8]
 80408bc:	0d1b      	lsrs	r3, r3, #20
 80408be:	f003 031f 	and.w	r3, r3, #31
 80408c2:	2107      	movs	r1, #7
 80408c4:	fa01 f303 	lsl.w	r3, r1, r3
 80408c8:	43db      	mvns	r3, r3
 80408ca:	401a      	ands	r2, r3
 80408cc:	68bb      	ldr	r3, [r7, #8]
 80408ce:	0d1b      	lsrs	r3, r3, #20
 80408d0:	f003 031f 	and.w	r3, r3, #31
 80408d4:	6879      	ldr	r1, [r7, #4]
 80408d6:	fa01 f303 	lsl.w	r3, r1, r3
 80408da:	4313      	orrs	r3, r2
 80408dc:	6023      	str	r3, [r4, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
 80408de:	bf00      	nop
 80408e0:	3710      	adds	r7, #16
 80408e2:	46bd      	mov	sp, r7
 80408e4:	bc90      	pop	{r4, r7}
 80408e6:	4770      	bx	lr

080408e8 <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 80408e8:	b480      	push	{r7}
 80408ea:	b085      	sub	sp, #20
 80408ec:	af00      	add	r7, sp, #0
 80408ee:	60f8      	str	r0, [r7, #12]
 80408f0:	60b9      	str	r1, [r7, #8]
 80408f2:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 80408f4:	68fb      	ldr	r3, [r7, #12]
 80408f6:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 80408fa:	68bb      	ldr	r3, [r7, #8]
 80408fc:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040900:	43db      	mvns	r3, r3
 8040902:	401a      	ands	r2, r3
 8040904:	687b      	ldr	r3, [r7, #4]
 8040906:	f003 0318 	and.w	r3, r3, #24
 804090a:	4908      	ldr	r1, [pc, #32]	; (804092c <LL_ADC_SetChannelSingleDiff+0x44>)
 804090c:	40d9      	lsrs	r1, r3
 804090e:	68bb      	ldr	r3, [r7, #8]
 8040910:	400b      	ands	r3, r1
 8040912:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040916:	431a      	orrs	r2, r3
 8040918:	68fb      	ldr	r3, [r7, #12]
 804091a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
 804091e:	bf00      	nop
 8040920:	3714      	adds	r7, #20
 8040922:	46bd      	mov	sp, r7
 8040924:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040928:	4770      	bx	lr
 804092a:	bf00      	nop
 804092c:	0007ffff 	.word	0x0007ffff

08040930 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 8040930:	b480      	push	{r7}
 8040932:	b083      	sub	sp, #12
 8040934:	af00      	add	r7, sp, #0
 8040936:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8040938:	687b      	ldr	r3, [r7, #4]
 804093a:	689b      	ldr	r3, [r3, #8]
 804093c:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8040940:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8040944:	687a      	ldr	r2, [r7, #4]
 8040946:	6093      	str	r3, [r2, #8]
}
 8040948:	bf00      	nop
 804094a:	370c      	adds	r7, #12
 804094c:	46bd      	mov	sp, r7
 804094e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040952:	4770      	bx	lr

08040954 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
 8040954:	b480      	push	{r7}
 8040956:	b083      	sub	sp, #12
 8040958:	af00      	add	r7, sp, #0
 804095a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 804095c:	687b      	ldr	r3, [r7, #4]
 804095e:	689b      	ldr	r3, [r3, #8]
 8040960:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8040964:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8040968:	d101      	bne.n	804096e <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 804096a:	2301      	movs	r3, #1
 804096c:	e000      	b.n	8040970 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 804096e:	2300      	movs	r3, #0
}
 8040970:	4618      	mov	r0, r3
 8040972:	370c      	adds	r7, #12
 8040974:	46bd      	mov	sp, r7
 8040976:	f85d 7b04 	ldr.w	r7, [sp], #4
 804097a:	4770      	bx	lr

0804097c <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 804097c:	b480      	push	{r7}
 804097e:	b083      	sub	sp, #12
 8040980:	af00      	add	r7, sp, #0
 8040982:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8040984:	687b      	ldr	r3, [r7, #4]
 8040986:	689b      	ldr	r3, [r3, #8]
 8040988:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 804098c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8040990:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 8040994:	687b      	ldr	r3, [r7, #4]
 8040996:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 8040998:	bf00      	nop
 804099a:	370c      	adds	r7, #12
 804099c:	46bd      	mov	sp, r7
 804099e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80409a2:	4770      	bx	lr

080409a4 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
 80409a4:	b480      	push	{r7}
 80409a6:	b083      	sub	sp, #12
 80409a8:	af00      	add	r7, sp, #0
 80409aa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80409ac:	687b      	ldr	r3, [r7, #4]
 80409ae:	689b      	ldr	r3, [r3, #8]
 80409b0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80409b4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80409b8:	d101      	bne.n	80409be <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 80409ba:	2301      	movs	r3, #1
 80409bc:	e000      	b.n	80409c0 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 80409be:	2300      	movs	r3, #0
}
 80409c0:	4618      	mov	r0, r3
 80409c2:	370c      	adds	r7, #12
 80409c4:	46bd      	mov	sp, r7
 80409c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80409ca:	4770      	bx	lr

080409cc <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
 80409cc:	b480      	push	{r7}
 80409ce:	b083      	sub	sp, #12
 80409d0:	af00      	add	r7, sp, #0
 80409d2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80409d4:	687b      	ldr	r3, [r7, #4]
 80409d6:	689b      	ldr	r3, [r3, #8]
 80409d8:	f003 0301 	and.w	r3, r3, #1
 80409dc:	2b01      	cmp	r3, #1
 80409de:	d101      	bne.n	80409e4 <LL_ADC_IsEnabled+0x18>
 80409e0:	2301      	movs	r3, #1
 80409e2:	e000      	b.n	80409e6 <LL_ADC_IsEnabled+0x1a>
 80409e4:	2300      	movs	r3, #0
}
 80409e6:	4618      	mov	r0, r3
 80409e8:	370c      	adds	r7, #12
 80409ea:	46bd      	mov	sp, r7
 80409ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80409f0:	4770      	bx	lr

080409f2 <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 80409f2:	b480      	push	{r7}
 80409f4:	b083      	sub	sp, #12
 80409f6:	af00      	add	r7, sp, #0
 80409f8:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80409fa:	687b      	ldr	r3, [r7, #4]
 80409fc:	689b      	ldr	r3, [r3, #8]
 80409fe:	f003 0304 	and.w	r3, r3, #4
 8040a02:	2b04      	cmp	r3, #4
 8040a04:	d101      	bne.n	8040a0a <LL_ADC_REG_IsConversionOngoing+0x18>
 8040a06:	2301      	movs	r3, #1
 8040a08:	e000      	b.n	8040a0c <LL_ADC_REG_IsConversionOngoing+0x1a>
 8040a0a:	2300      	movs	r3, #0
}
 8040a0c:	4618      	mov	r0, r3
 8040a0e:	370c      	adds	r7, #12
 8040a10:	46bd      	mov	sp, r7
 8040a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040a16:	4770      	bx	lr

08040a18 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 8040a18:	b480      	push	{r7}
 8040a1a:	b083      	sub	sp, #12
 8040a1c:	af00      	add	r7, sp, #0
 8040a1e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8040a20:	687b      	ldr	r3, [r7, #4]
 8040a22:	689b      	ldr	r3, [r3, #8]
 8040a24:	f003 0308 	and.w	r3, r3, #8
 8040a28:	2b08      	cmp	r3, #8
 8040a2a:	d101      	bne.n	8040a30 <LL_ADC_INJ_IsConversionOngoing+0x18>
 8040a2c:	2301      	movs	r3, #1
 8040a2e:	e000      	b.n	8040a32 <LL_ADC_INJ_IsConversionOngoing+0x1a>
 8040a30:	2300      	movs	r3, #0
}
 8040a32:	4618      	mov	r0, r3
 8040a34:	370c      	adds	r7, #12
 8040a36:	46bd      	mov	sp, r7
 8040a38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8040a3c:	4770      	bx	lr
	...

08040a40 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8040a40:	b590      	push	{r4, r7, lr}
 8040a42:	b089      	sub	sp, #36	; 0x24
 8040a44:	af00      	add	r7, sp, #0
 8040a46:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8040a48:	2300      	movs	r3, #0
 8040a4a:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8040a4c:	2300      	movs	r3, #0
 8040a4e:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8040a50:	687b      	ldr	r3, [r7, #4]
 8040a52:	2b00      	cmp	r3, #0
 8040a54:	d101      	bne.n	8040a5a <HAL_ADC_Init+0x1a>
  {
    return HAL_ERROR;
 8040a56:	2301      	movs	r3, #1
 8040a58:	e132      	b.n	8040cc0 <HAL_ADC_Init+0x280>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8040a5a:	687b      	ldr	r3, [r7, #4]
 8040a5c:	691b      	ldr	r3, [r3, #16]
 8040a5e:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8040a60:	687b      	ldr	r3, [r7, #4]
 8040a62:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040a64:	2b00      	cmp	r3, #0
 8040a66:	d109      	bne.n	8040a7c <HAL_ADC_Init+0x3c>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8040a68:	6878      	ldr	r0, [r7, #4]
 8040a6a:	f7ff fd11 	bl	8040490 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8040a6e:	687b      	ldr	r3, [r7, #4]
 8040a70:	2200      	movs	r2, #0
 8040a72:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8040a74:	687b      	ldr	r3, [r7, #4]
 8040a76:	2200      	movs	r2, #0
 8040a78:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8040a7c:	687b      	ldr	r3, [r7, #4]
 8040a7e:	681b      	ldr	r3, [r3, #0]
 8040a80:	4618      	mov	r0, r3
 8040a82:	f7ff ff67 	bl	8040954 <LL_ADC_IsDeepPowerDownEnabled>
 8040a86:	4603      	mov	r3, r0
 8040a88:	2b00      	cmp	r3, #0
 8040a8a:	d004      	beq.n	8040a96 <HAL_ADC_Init+0x56>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 8040a8c:	687b      	ldr	r3, [r7, #4]
 8040a8e:	681b      	ldr	r3, [r3, #0]
 8040a90:	4618      	mov	r0, r3
 8040a92:	f7ff ff4d 	bl	8040930 <LL_ADC_DisableDeepPowerDown>
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8040a96:	687b      	ldr	r3, [r7, #4]
 8040a98:	681b      	ldr	r3, [r3, #0]
 8040a9a:	4618      	mov	r0, r3
 8040a9c:	f7ff ff82 	bl	80409a4 <LL_ADC_IsInternalRegulatorEnabled>
 8040aa0:	4603      	mov	r3, r0
 8040aa2:	2b00      	cmp	r3, #0
 8040aa4:	d113      	bne.n	8040ace <HAL_ADC_Init+0x8e>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 8040aa6:	687b      	ldr	r3, [r7, #4]
 8040aa8:	681b      	ldr	r3, [r3, #0]
 8040aaa:	4618      	mov	r0, r3
 8040aac:	f7ff ff66 	bl	804097c <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8040ab0:	4b85      	ldr	r3, [pc, #532]	; (8040cc8 <HAL_ADC_Init+0x288>)
 8040ab2:	681b      	ldr	r3, [r3, #0]
 8040ab4:	099b      	lsrs	r3, r3, #6
 8040ab6:	4a85      	ldr	r2, [pc, #532]	; (8040ccc <HAL_ADC_Init+0x28c>)
 8040ab8:	fba2 2303 	umull	r2, r3, r2, r3
 8040abc:	099b      	lsrs	r3, r3, #6
 8040abe:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8040ac0:	e002      	b.n	8040ac8 <HAL_ADC_Init+0x88>
    {
      wait_loop_index--;
 8040ac2:	68bb      	ldr	r3, [r7, #8]
 8040ac4:	3b01      	subs	r3, #1
 8040ac6:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8040ac8:	68bb      	ldr	r3, [r7, #8]
 8040aca:	2b00      	cmp	r3, #0
 8040acc:	d1f9      	bne.n	8040ac2 <HAL_ADC_Init+0x82>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8040ace:	687b      	ldr	r3, [r7, #4]
 8040ad0:	681b      	ldr	r3, [r3, #0]
 8040ad2:	4618      	mov	r0, r3
 8040ad4:	f7ff ff66 	bl	80409a4 <LL_ADC_IsInternalRegulatorEnabled>
 8040ad8:	4603      	mov	r3, r0
 8040ada:	2b00      	cmp	r3, #0
 8040adc:	d10d      	bne.n	8040afa <HAL_ADC_Init+0xba>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8040ade:	687b      	ldr	r3, [r7, #4]
 8040ae0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040ae2:	f043 0210 	orr.w	r2, r3, #16
 8040ae6:	687b      	ldr	r3, [r7, #4]
 8040ae8:	659a      	str	r2, [r3, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8040aea:	687b      	ldr	r3, [r7, #4]
 8040aec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8040aee:	f043 0201 	orr.w	r2, r3, #1
 8040af2:	687b      	ldr	r3, [r7, #4]
 8040af4:	65da      	str	r2, [r3, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 8040af6:	2301      	movs	r3, #1
 8040af8:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8040afa:	687b      	ldr	r3, [r7, #4]
 8040afc:	681b      	ldr	r3, [r3, #0]
 8040afe:	4618      	mov	r0, r3
 8040b00:	f7ff ff77 	bl	80409f2 <LL_ADC_REG_IsConversionOngoing>
 8040b04:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8040b06:	687b      	ldr	r3, [r7, #4]
 8040b08:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040b0a:	f003 0310 	and.w	r3, r3, #16
 8040b0e:	2b00      	cmp	r3, #0
 8040b10:	f040 80cd 	bne.w	8040cae <HAL_ADC_Init+0x26e>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 8040b14:	697b      	ldr	r3, [r7, #20]
 8040b16:	2b00      	cmp	r3, #0
 8040b18:	f040 80c9 	bne.w	8040cae <HAL_ADC_Init+0x26e>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8040b1c:	687b      	ldr	r3, [r7, #4]
 8040b1e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040b20:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8040b24:	f043 0202 	orr.w	r2, r3, #2
 8040b28:	687b      	ldr	r3, [r7, #4]
 8040b2a:	659a      	str	r2, [r3, #88]	; 0x58
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8040b2c:	687b      	ldr	r3, [r7, #4]
 8040b2e:	681b      	ldr	r3, [r3, #0]
 8040b30:	4618      	mov	r0, r3
 8040b32:	f7ff ff4b 	bl	80409cc <LL_ADC_IsEnabled>
 8040b36:	4603      	mov	r3, r0
 8040b38:	2b00      	cmp	r3, #0
 8040b3a:	d110      	bne.n	8040b5e <HAL_ADC_Init+0x11e>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8040b3c:	4864      	ldr	r0, [pc, #400]	; (8040cd0 <HAL_ADC_Init+0x290>)
 8040b3e:	f7ff ff45 	bl	80409cc <LL_ADC_IsEnabled>
 8040b42:	4604      	mov	r4, r0
 8040b44:	4863      	ldr	r0, [pc, #396]	; (8040cd4 <HAL_ADC_Init+0x294>)
 8040b46:	f7ff ff41 	bl	80409cc <LL_ADC_IsEnabled>
 8040b4a:	4603      	mov	r3, r0
 8040b4c:	4323      	orrs	r3, r4
 8040b4e:	2b00      	cmp	r3, #0
 8040b50:	d105      	bne.n	8040b5e <HAL_ADC_Init+0x11e>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8040b52:	687b      	ldr	r3, [r7, #4]
 8040b54:	685b      	ldr	r3, [r3, #4]
 8040b56:	4619      	mov	r1, r3
 8040b58:	485f      	ldr	r0, [pc, #380]	; (8040cd8 <HAL_ADC_Init+0x298>)
 8040b5a:	f7ff fddf 	bl	804071c <LL_ADC_SetCommonClock>
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8040b5e:	687b      	ldr	r3, [r7, #4]
 8040b60:	7e5b      	ldrb	r3, [r3, #25]
 8040b62:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                     |
 8040b64:	687b      	ldr	r3, [r7, #4]
 8040b66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8040b68:	431a      	orrs	r2, r3
                hadc->Init.DataAlign                                                   |
 8040b6a:	687b      	ldr	r3, [r7, #4]
 8040b6c:	68db      	ldr	r3, [r3, #12]
                hadc->Init.Overrun                                                     |
 8040b6e:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                  |
 8040b70:	687b      	ldr	r3, [r7, #4]
 8040b72:	689b      	ldr	r3, [r3, #8]
                hadc->Init.DataAlign                                                   |
 8040b74:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8040b76:	687b      	ldr	r3, [r7, #4]
 8040b78:	f893 3020 	ldrb.w	r3, [r3, #32]
 8040b7c:	041b      	lsls	r3, r3, #16
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8040b7e:	4313      	orrs	r3, r2
 8040b80:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8040b82:	687b      	ldr	r3, [r7, #4]
 8040b84:	f893 3020 	ldrb.w	r3, [r3, #32]
 8040b88:	2b01      	cmp	r3, #1
 8040b8a:	d106      	bne.n	8040b9a <HAL_ADC_Init+0x15a>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8040b8c:	687b      	ldr	r3, [r7, #4]
 8040b8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8040b90:	3b01      	subs	r3, #1
 8040b92:	045b      	lsls	r3, r3, #17
 8040b94:	69ba      	ldr	r2, [r7, #24]
 8040b96:	4313      	orrs	r3, r2
 8040b98:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8040b9a:	687b      	ldr	r3, [r7, #4]
 8040b9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8040b9e:	2b00      	cmp	r3, #0
 8040ba0:	d009      	beq.n	8040bb6 <HAL_ADC_Init+0x176>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8040ba2:	687b      	ldr	r3, [r7, #4]
 8040ba4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8040ba6:	f403 7270 	and.w	r2, r3, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 8040baa:	687b      	ldr	r3, [r7, #4]
 8040bac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8040bae:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8040bb0:	69ba      	ldr	r2, [r7, #24]
 8040bb2:	4313      	orrs	r3, r2
 8040bb4:	61bb      	str	r3, [r7, #24]
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8040bb6:	687b      	ldr	r3, [r7, #4]
 8040bb8:	681b      	ldr	r3, [r3, #0]
 8040bba:	68da      	ldr	r2, [r3, #12]
 8040bbc:	4b47      	ldr	r3, [pc, #284]	; (8040cdc <HAL_ADC_Init+0x29c>)
 8040bbe:	4013      	ands	r3, r2
 8040bc0:	687a      	ldr	r2, [r7, #4]
 8040bc2:	6812      	ldr	r2, [r2, #0]
 8040bc4:	69b9      	ldr	r1, [r7, #24]
 8040bc6:	430b      	orrs	r3, r1
 8040bc8:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8040bca:	687b      	ldr	r3, [r7, #4]
 8040bcc:	681b      	ldr	r3, [r3, #0]
 8040bce:	4618      	mov	r0, r3
 8040bd0:	f7ff ff0f 	bl	80409f2 <LL_ADC_REG_IsConversionOngoing>
 8040bd4:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8040bd6:	687b      	ldr	r3, [r7, #4]
 8040bd8:	681b      	ldr	r3, [r3, #0]
 8040bda:	4618      	mov	r0, r3
 8040bdc:	f7ff ff1c 	bl	8040a18 <LL_ADC_INJ_IsConversionOngoing>
 8040be0:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8040be2:	693b      	ldr	r3, [r7, #16]
 8040be4:	2b00      	cmp	r3, #0
 8040be6:	d140      	bne.n	8040c6a <HAL_ADC_Init+0x22a>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8040be8:	68fb      	ldr	r3, [r7, #12]
 8040bea:	2b00      	cmp	r3, #0
 8040bec:	d13d      	bne.n	8040c6a <HAL_ADC_Init+0x22a>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8040bee:	687b      	ldr	r3, [r7, #4]
 8040bf0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8040bf2:	687b      	ldr	r3, [r7, #4]
 8040bf4:	7e1b      	ldrb	r3, [r3, #24]
 8040bf6:	039b      	lsls	r3, r3, #14
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8040bf8:	431a      	orrs	r2, r3
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8040bfa:	687b      	ldr	r3, [r7, #4]
 8040bfc:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8040c00:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8040c02:	4313      	orrs	r3, r2
 8040c04:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8040c06:	687b      	ldr	r3, [r7, #4]
 8040c08:	681b      	ldr	r3, [r3, #0]
 8040c0a:	68db      	ldr	r3, [r3, #12]
 8040c0c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8040c10:	f023 0306 	bic.w	r3, r3, #6
 8040c14:	687a      	ldr	r2, [r7, #4]
 8040c16:	6812      	ldr	r2, [r2, #0]
 8040c18:	69b9      	ldr	r1, [r7, #24]
 8040c1a:	430b      	orrs	r3, r1
 8040c1c:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 8040c1e:	687b      	ldr	r3, [r7, #4]
 8040c20:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8040c24:	2b01      	cmp	r3, #1
 8040c26:	d118      	bne.n	8040c5a <HAL_ADC_Init+0x21a>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 8040c28:	687b      	ldr	r3, [r7, #4]
 8040c2a:	681b      	ldr	r3, [r3, #0]
 8040c2c:	691b      	ldr	r3, [r3, #16]
 8040c2e:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8040c32:	f023 0304 	bic.w	r3, r3, #4
 8040c36:	687a      	ldr	r2, [r7, #4]
 8040c38:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 8040c3a:	687a      	ldr	r2, [r7, #4]
 8040c3c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8040c3e:	4311      	orrs	r1, r2
 8040c40:	687a      	ldr	r2, [r7, #4]
 8040c42:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8040c44:	4311      	orrs	r1, r2
 8040c46:	687a      	ldr	r2, [r7, #4]
 8040c48:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8040c4a:	430a      	orrs	r2, r1
 8040c4c:	431a      	orrs	r2, r3
 8040c4e:	687b      	ldr	r3, [r7, #4]
 8040c50:	681b      	ldr	r3, [r3, #0]
 8040c52:	f042 0201 	orr.w	r2, r2, #1
 8040c56:	611a      	str	r2, [r3, #16]
 8040c58:	e007      	b.n	8040c6a <HAL_ADC_Init+0x22a>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8040c5a:	687b      	ldr	r3, [r7, #4]
 8040c5c:	681b      	ldr	r3, [r3, #0]
 8040c5e:	691a      	ldr	r2, [r3, #16]
 8040c60:	687b      	ldr	r3, [r7, #4]
 8040c62:	681b      	ldr	r3, [r3, #0]
 8040c64:	f022 0201 	bic.w	r2, r2, #1
 8040c68:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8040c6a:	687b      	ldr	r3, [r7, #4]
 8040c6c:	691b      	ldr	r3, [r3, #16]
 8040c6e:	2b01      	cmp	r3, #1
 8040c70:	d10c      	bne.n	8040c8c <HAL_ADC_Init+0x24c>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8040c72:	687b      	ldr	r3, [r7, #4]
 8040c74:	681b      	ldr	r3, [r3, #0]
 8040c76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8040c78:	f023 010f 	bic.w	r1, r3, #15
 8040c7c:	687b      	ldr	r3, [r7, #4]
 8040c7e:	69db      	ldr	r3, [r3, #28]
 8040c80:	1e5a      	subs	r2, r3, #1
 8040c82:	687b      	ldr	r3, [r7, #4]
 8040c84:	681b      	ldr	r3, [r3, #0]
 8040c86:	430a      	orrs	r2, r1
 8040c88:	631a      	str	r2, [r3, #48]	; 0x30
 8040c8a:	e007      	b.n	8040c9c <HAL_ADC_Init+0x25c>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8040c8c:	687b      	ldr	r3, [r7, #4]
 8040c8e:	681b      	ldr	r3, [r3, #0]
 8040c90:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8040c92:	687b      	ldr	r3, [r7, #4]
 8040c94:	681b      	ldr	r3, [r3, #0]
 8040c96:	f022 020f 	bic.w	r2, r2, #15
 8040c9a:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8040c9c:	687b      	ldr	r3, [r7, #4]
 8040c9e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040ca0:	f023 0303 	bic.w	r3, r3, #3
 8040ca4:	f043 0201 	orr.w	r2, r3, #1
 8040ca8:	687b      	ldr	r3, [r7, #4]
 8040caa:	659a      	str	r2, [r3, #88]	; 0x58
 8040cac:	e007      	b.n	8040cbe <HAL_ADC_Init+0x27e>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8040cae:	687b      	ldr	r3, [r7, #4]
 8040cb0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8040cb2:	f043 0210 	orr.w	r2, r3, #16
 8040cb6:	687b      	ldr	r3, [r7, #4]
 8040cb8:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8040cba:	2301      	movs	r3, #1
 8040cbc:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 8040cbe:	7ffb      	ldrb	r3, [r7, #31]
}
 8040cc0:	4618      	mov	r0, r3
 8040cc2:	3724      	adds	r7, #36	; 0x24
 8040cc4:	46bd      	mov	sp, r7
 8040cc6:	bd90      	pop	{r4, r7, pc}
 8040cc8:	20018000 	.word	0x20018000
 8040ccc:	053e2d63 	.word	0x053e2d63
 8040cd0:	42028000 	.word	0x42028000
 8040cd4:	42028100 	.word	0x42028100
 8040cd8:	42028300 	.word	0x42028300
 8040cdc:	fff0c007 	.word	0xfff0c007

08040ce0 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8040ce0:	b590      	push	{r4, r7, lr}
 8040ce2:	b0a7      	sub	sp, #156	; 0x9c
 8040ce4:	af00      	add	r7, sp, #0
 8040ce6:	6078      	str	r0, [r7, #4]
 8040ce8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8040cea:	2300      	movs	r3, #0
 8040cec:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 8040cf0:	2300      	movs	r3, #0
 8040cf2:	60bb      	str	r3, [r7, #8]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8040cf4:	687b      	ldr	r3, [r7, #4]
 8040cf6:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8040cfa:	2b01      	cmp	r3, #1
 8040cfc:	d101      	bne.n	8040d02 <HAL_ADC_ConfigChannel+0x22>
 8040cfe:	2302      	movs	r3, #2
 8040d00:	e340      	b.n	8041384 <HAL_ADC_ConfigChannel+0x6a4>
 8040d02:	687b      	ldr	r3, [r7, #4]
 8040d04:	2201      	movs	r2, #1
 8040d06:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8040d0a:	687b      	ldr	r3, [r7, #4]
 8040d0c:	681b      	ldr	r3, [r3, #0]
 8040d0e:	4618      	mov	r0, r3
 8040d10:	f7ff fe6f 	bl	80409f2 <LL_ADC_REG_IsConversionOngoing>
 8040d14:	4603      	mov	r3, r0
 8040d16:	2b00      	cmp	r3, #0
 8040d18:	f040 8325 	bne.w	8041366 <HAL_ADC_ConfigChannel+0x686>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8040d1c:	687b      	ldr	r3, [r7, #4]
 8040d1e:	6818      	ldr	r0, [r3, #0]
 8040d20:	683b      	ldr	r3, [r7, #0]
 8040d22:	6859      	ldr	r1, [r3, #4]
 8040d24:	683b      	ldr	r3, [r7, #0]
 8040d26:	681b      	ldr	r3, [r3, #0]
 8040d28:	461a      	mov	r2, r3
 8040d2a:	f7ff fd8c 	bl	8040846 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8040d2e:	687b      	ldr	r3, [r7, #4]
 8040d30:	681b      	ldr	r3, [r3, #0]
 8040d32:	4618      	mov	r0, r3
 8040d34:	f7ff fe5d 	bl	80409f2 <LL_ADC_REG_IsConversionOngoing>
 8040d38:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8040d3c:	687b      	ldr	r3, [r7, #4]
 8040d3e:	681b      	ldr	r3, [r3, #0]
 8040d40:	4618      	mov	r0, r3
 8040d42:	f7ff fe69 	bl	8040a18 <LL_ADC_INJ_IsConversionOngoing>
 8040d46:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8040d4a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8040d4e:	2b00      	cmp	r3, #0
 8040d50:	f040 8163 	bne.w	804101a <HAL_ADC_ConfigChannel+0x33a>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8040d54:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8040d58:	2b00      	cmp	r3, #0
 8040d5a:	f040 815e 	bne.w	804101a <HAL_ADC_ConfigChannel+0x33a>
       )
    {
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8040d5e:	683b      	ldr	r3, [r7, #0]
 8040d60:	689b      	ldr	r3, [r3, #8]
 8040d62:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8040d66:	d10f      	bne.n	8040d88 <HAL_ADC_ConfigChannel+0xa8>
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 8040d68:	687b      	ldr	r3, [r7, #4]
 8040d6a:	6818      	ldr	r0, [r3, #0]
 8040d6c:	683b      	ldr	r3, [r7, #0]
 8040d6e:	681b      	ldr	r3, [r3, #0]
 8040d70:	2200      	movs	r2, #0
 8040d72:	4619      	mov	r1, r3
 8040d74:	f7ff fd90 	bl	8040898 <LL_ADC_SetChannelSamplingTime>

        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 8040d78:	687b      	ldr	r3, [r7, #4]
 8040d7a:	681b      	ldr	r3, [r3, #0]
 8040d7c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8040d80:	4618      	mov	r0, r3
 8040d82:	f7ff fd4d 	bl	8040820 <LL_ADC_SetSamplingTimeCommonConfig>
 8040d86:	e00e      	b.n	8040da6 <HAL_ADC_ConfigChannel+0xc6>
      }
      else
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8040d88:	687b      	ldr	r3, [r7, #4]
 8040d8a:	6818      	ldr	r0, [r3, #0]
 8040d8c:	683b      	ldr	r3, [r7, #0]
 8040d8e:	6819      	ldr	r1, [r3, #0]
 8040d90:	683b      	ldr	r3, [r7, #0]
 8040d92:	689b      	ldr	r3, [r3, #8]
 8040d94:	461a      	mov	r2, r3
 8040d96:	f7ff fd7f 	bl	8040898 <LL_ADC_SetChannelSamplingTime>

        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 8040d9a:	687b      	ldr	r3, [r7, #4]
 8040d9c:	681b      	ldr	r3, [r3, #0]
 8040d9e:	2100      	movs	r1, #0
 8040da0:	4618      	mov	r0, r3
 8040da2:	f7ff fd3d 	bl	8040820 <LL_ADC_SetSamplingTimeCommonConfig>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8040da6:	683b      	ldr	r3, [r7, #0]
 8040da8:	695a      	ldr	r2, [r3, #20]
 8040daa:	687b      	ldr	r3, [r7, #4]
 8040dac:	681b      	ldr	r3, [r3, #0]
 8040dae:	68db      	ldr	r3, [r3, #12]
 8040db0:	08db      	lsrs	r3, r3, #3
 8040db2:	f003 0303 	and.w	r3, r3, #3
 8040db6:	005b      	lsls	r3, r3, #1
 8040db8:	fa02 f303 	lsl.w	r3, r2, r3
 8040dbc:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8040dc0:	683b      	ldr	r3, [r7, #0]
 8040dc2:	691b      	ldr	r3, [r3, #16]
 8040dc4:	2b04      	cmp	r3, #4
 8040dc6:	d00a      	beq.n	8040dde <HAL_ADC_ConfigChannel+0xfe>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8040dc8:	687b      	ldr	r3, [r7, #4]
 8040dca:	6818      	ldr	r0, [r3, #0]
 8040dcc:	683b      	ldr	r3, [r7, #0]
 8040dce:	6919      	ldr	r1, [r3, #16]
 8040dd0:	683b      	ldr	r3, [r7, #0]
 8040dd2:	681a      	ldr	r2, [r3, #0]
 8040dd4:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8040dd8:	f7ff fcd4 	bl	8040784 <LL_ADC_SetOffset>
 8040ddc:	e11d      	b.n	804101a <HAL_ADC_ConfigChannel+0x33a>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8040dde:	687b      	ldr	r3, [r7, #4]
 8040de0:	681b      	ldr	r3, [r3, #0]
 8040de2:	2100      	movs	r1, #0
 8040de4:	4618      	mov	r0, r3
 8040de6:	f7ff fcef 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040dea:	4603      	mov	r3, r0
 8040dec:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040df0:	2b00      	cmp	r3, #0
 8040df2:	d10a      	bne.n	8040e0a <HAL_ADC_ConfigChannel+0x12a>
 8040df4:	687b      	ldr	r3, [r7, #4]
 8040df6:	681b      	ldr	r3, [r3, #0]
 8040df8:	2100      	movs	r1, #0
 8040dfa:	4618      	mov	r0, r3
 8040dfc:	f7ff fce4 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040e00:	4603      	mov	r3, r0
 8040e02:	0e9b      	lsrs	r3, r3, #26
 8040e04:	f003 021f 	and.w	r2, r3, #31
 8040e08:	e012      	b.n	8040e30 <HAL_ADC_ConfigChannel+0x150>
 8040e0a:	687b      	ldr	r3, [r7, #4]
 8040e0c:	681b      	ldr	r3, [r3, #0]
 8040e0e:	2100      	movs	r1, #0
 8040e10:	4618      	mov	r0, r3
 8040e12:	f7ff fcd9 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040e16:	4603      	mov	r3, r0
 8040e18:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040e1c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8040e20:	fa93 f3a3 	rbit	r3, r3
 8040e24:	67fb      	str	r3, [r7, #124]	; 0x7c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8040e26:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8040e28:	fab3 f383 	clz	r3, r3
 8040e2c:	b2db      	uxtb	r3, r3
 8040e2e:	461a      	mov	r2, r3
 8040e30:	683b      	ldr	r3, [r7, #0]
 8040e32:	681b      	ldr	r3, [r3, #0]
 8040e34:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040e38:	2b00      	cmp	r3, #0
 8040e3a:	d105      	bne.n	8040e48 <HAL_ADC_ConfigChannel+0x168>
 8040e3c:	683b      	ldr	r3, [r7, #0]
 8040e3e:	681b      	ldr	r3, [r3, #0]
 8040e40:	0e9b      	lsrs	r3, r3, #26
 8040e42:	f003 031f 	and.w	r3, r3, #31
 8040e46:	e00a      	b.n	8040e5e <HAL_ADC_ConfigChannel+0x17e>
 8040e48:	683b      	ldr	r3, [r7, #0]
 8040e4a:	681b      	ldr	r3, [r3, #0]
 8040e4c:	67bb      	str	r3, [r7, #120]	; 0x78
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040e4e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8040e50:	fa93 f3a3 	rbit	r3, r3
 8040e54:	677b      	str	r3, [r7, #116]	; 0x74
  return result;
 8040e56:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8040e58:	fab3 f383 	clz	r3, r3
 8040e5c:	b2db      	uxtb	r3, r3
 8040e5e:	429a      	cmp	r2, r3
 8040e60:	d106      	bne.n	8040e70 <HAL_ADC_ConfigChannel+0x190>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 8040e62:	687b      	ldr	r3, [r7, #4]
 8040e64:	681b      	ldr	r3, [r3, #0]
 8040e66:	2200      	movs	r2, #0
 8040e68:	2100      	movs	r1, #0
 8040e6a:	4618      	mov	r0, r3
 8040e6c:	f7ff fcc0 	bl	80407f0 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8040e70:	687b      	ldr	r3, [r7, #4]
 8040e72:	681b      	ldr	r3, [r3, #0]
 8040e74:	2101      	movs	r1, #1
 8040e76:	4618      	mov	r0, r3
 8040e78:	f7ff fca6 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040e7c:	4603      	mov	r3, r0
 8040e7e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040e82:	2b00      	cmp	r3, #0
 8040e84:	d10a      	bne.n	8040e9c <HAL_ADC_ConfigChannel+0x1bc>
 8040e86:	687b      	ldr	r3, [r7, #4]
 8040e88:	681b      	ldr	r3, [r3, #0]
 8040e8a:	2101      	movs	r1, #1
 8040e8c:	4618      	mov	r0, r3
 8040e8e:	f7ff fc9b 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040e92:	4603      	mov	r3, r0
 8040e94:	0e9b      	lsrs	r3, r3, #26
 8040e96:	f003 021f 	and.w	r2, r3, #31
 8040e9a:	e010      	b.n	8040ebe <HAL_ADC_ConfigChannel+0x1de>
 8040e9c:	687b      	ldr	r3, [r7, #4]
 8040e9e:	681b      	ldr	r3, [r3, #0]
 8040ea0:	2101      	movs	r1, #1
 8040ea2:	4618      	mov	r0, r3
 8040ea4:	f7ff fc90 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040ea8:	4603      	mov	r3, r0
 8040eaa:	673b      	str	r3, [r7, #112]	; 0x70
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040eac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8040eae:	fa93 f3a3 	rbit	r3, r3
 8040eb2:	66fb      	str	r3, [r7, #108]	; 0x6c
  return result;
 8040eb4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8040eb6:	fab3 f383 	clz	r3, r3
 8040eba:	b2db      	uxtb	r3, r3
 8040ebc:	461a      	mov	r2, r3
 8040ebe:	683b      	ldr	r3, [r7, #0]
 8040ec0:	681b      	ldr	r3, [r3, #0]
 8040ec2:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040ec6:	2b00      	cmp	r3, #0
 8040ec8:	d105      	bne.n	8040ed6 <HAL_ADC_ConfigChannel+0x1f6>
 8040eca:	683b      	ldr	r3, [r7, #0]
 8040ecc:	681b      	ldr	r3, [r3, #0]
 8040ece:	0e9b      	lsrs	r3, r3, #26
 8040ed0:	f003 031f 	and.w	r3, r3, #31
 8040ed4:	e00a      	b.n	8040eec <HAL_ADC_ConfigChannel+0x20c>
 8040ed6:	683b      	ldr	r3, [r7, #0]
 8040ed8:	681b      	ldr	r3, [r3, #0]
 8040eda:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040edc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8040ede:	fa93 f3a3 	rbit	r3, r3
 8040ee2:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 8040ee4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8040ee6:	fab3 f383 	clz	r3, r3
 8040eea:	b2db      	uxtb	r3, r3
 8040eec:	429a      	cmp	r2, r3
 8040eee:	d106      	bne.n	8040efe <HAL_ADC_ConfigChannel+0x21e>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 8040ef0:	687b      	ldr	r3, [r7, #4]
 8040ef2:	681b      	ldr	r3, [r3, #0]
 8040ef4:	2200      	movs	r2, #0
 8040ef6:	2101      	movs	r1, #1
 8040ef8:	4618      	mov	r0, r3
 8040efa:	f7ff fc79 	bl	80407f0 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8040efe:	687b      	ldr	r3, [r7, #4]
 8040f00:	681b      	ldr	r3, [r3, #0]
 8040f02:	2102      	movs	r1, #2
 8040f04:	4618      	mov	r0, r3
 8040f06:	f7ff fc5f 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040f0a:	4603      	mov	r3, r0
 8040f0c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040f10:	2b00      	cmp	r3, #0
 8040f12:	d10a      	bne.n	8040f2a <HAL_ADC_ConfigChannel+0x24a>
 8040f14:	687b      	ldr	r3, [r7, #4]
 8040f16:	681b      	ldr	r3, [r3, #0]
 8040f18:	2102      	movs	r1, #2
 8040f1a:	4618      	mov	r0, r3
 8040f1c:	f7ff fc54 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040f20:	4603      	mov	r3, r0
 8040f22:	0e9b      	lsrs	r3, r3, #26
 8040f24:	f003 021f 	and.w	r2, r3, #31
 8040f28:	e010      	b.n	8040f4c <HAL_ADC_ConfigChannel+0x26c>
 8040f2a:	687b      	ldr	r3, [r7, #4]
 8040f2c:	681b      	ldr	r3, [r3, #0]
 8040f2e:	2102      	movs	r1, #2
 8040f30:	4618      	mov	r0, r3
 8040f32:	f7ff fc49 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040f36:	4603      	mov	r3, r0
 8040f38:	663b      	str	r3, [r7, #96]	; 0x60
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040f3a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8040f3c:	fa93 f3a3 	rbit	r3, r3
 8040f40:	65fb      	str	r3, [r7, #92]	; 0x5c
  return result;
 8040f42:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8040f44:	fab3 f383 	clz	r3, r3
 8040f48:	b2db      	uxtb	r3, r3
 8040f4a:	461a      	mov	r2, r3
 8040f4c:	683b      	ldr	r3, [r7, #0]
 8040f4e:	681b      	ldr	r3, [r3, #0]
 8040f50:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040f54:	2b00      	cmp	r3, #0
 8040f56:	d105      	bne.n	8040f64 <HAL_ADC_ConfigChannel+0x284>
 8040f58:	683b      	ldr	r3, [r7, #0]
 8040f5a:	681b      	ldr	r3, [r3, #0]
 8040f5c:	0e9b      	lsrs	r3, r3, #26
 8040f5e:	f003 031f 	and.w	r3, r3, #31
 8040f62:	e00a      	b.n	8040f7a <HAL_ADC_ConfigChannel+0x29a>
 8040f64:	683b      	ldr	r3, [r7, #0]
 8040f66:	681b      	ldr	r3, [r3, #0]
 8040f68:	65bb      	str	r3, [r7, #88]	; 0x58
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040f6a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8040f6c:	fa93 f3a3 	rbit	r3, r3
 8040f70:	657b      	str	r3, [r7, #84]	; 0x54
  return result;
 8040f72:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8040f74:	fab3 f383 	clz	r3, r3
 8040f78:	b2db      	uxtb	r3, r3
 8040f7a:	429a      	cmp	r2, r3
 8040f7c:	d106      	bne.n	8040f8c <HAL_ADC_ConfigChannel+0x2ac>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 8040f7e:	687b      	ldr	r3, [r7, #4]
 8040f80:	681b      	ldr	r3, [r3, #0]
 8040f82:	2200      	movs	r2, #0
 8040f84:	2102      	movs	r1, #2
 8040f86:	4618      	mov	r0, r3
 8040f88:	f7ff fc32 	bl	80407f0 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8040f8c:	687b      	ldr	r3, [r7, #4]
 8040f8e:	681b      	ldr	r3, [r3, #0]
 8040f90:	2103      	movs	r1, #3
 8040f92:	4618      	mov	r0, r3
 8040f94:	f7ff fc18 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040f98:	4603      	mov	r3, r0
 8040f9a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040f9e:	2b00      	cmp	r3, #0
 8040fa0:	d10a      	bne.n	8040fb8 <HAL_ADC_ConfigChannel+0x2d8>
 8040fa2:	687b      	ldr	r3, [r7, #4]
 8040fa4:	681b      	ldr	r3, [r3, #0]
 8040fa6:	2103      	movs	r1, #3
 8040fa8:	4618      	mov	r0, r3
 8040faa:	f7ff fc0d 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040fae:	4603      	mov	r3, r0
 8040fb0:	0e9b      	lsrs	r3, r3, #26
 8040fb2:	f003 021f 	and.w	r2, r3, #31
 8040fb6:	e010      	b.n	8040fda <HAL_ADC_ConfigChannel+0x2fa>
 8040fb8:	687b      	ldr	r3, [r7, #4]
 8040fba:	681b      	ldr	r3, [r3, #0]
 8040fbc:	2103      	movs	r1, #3
 8040fbe:	4618      	mov	r0, r3
 8040fc0:	f7ff fc02 	bl	80407c8 <LL_ADC_GetOffsetChannel>
 8040fc4:	4603      	mov	r3, r0
 8040fc6:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040fc8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8040fca:	fa93 f3a3 	rbit	r3, r3
 8040fce:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 8040fd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8040fd2:	fab3 f383 	clz	r3, r3
 8040fd6:	b2db      	uxtb	r3, r3
 8040fd8:	461a      	mov	r2, r3
 8040fda:	683b      	ldr	r3, [r7, #0]
 8040fdc:	681b      	ldr	r3, [r3, #0]
 8040fde:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8040fe2:	2b00      	cmp	r3, #0
 8040fe4:	d105      	bne.n	8040ff2 <HAL_ADC_ConfigChannel+0x312>
 8040fe6:	683b      	ldr	r3, [r7, #0]
 8040fe8:	681b      	ldr	r3, [r3, #0]
 8040fea:	0e9b      	lsrs	r3, r3, #26
 8040fec:	f003 031f 	and.w	r3, r3, #31
 8040ff0:	e00a      	b.n	8041008 <HAL_ADC_ConfigChannel+0x328>
 8040ff2:	683b      	ldr	r3, [r7, #0]
 8040ff4:	681b      	ldr	r3, [r3, #0]
 8040ff6:	64bb      	str	r3, [r7, #72]	; 0x48
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8040ff8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8040ffa:	fa93 f3a3 	rbit	r3, r3
 8040ffe:	647b      	str	r3, [r7, #68]	; 0x44
  return result;
 8041000:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8041002:	fab3 f383 	clz	r3, r3
 8041006:	b2db      	uxtb	r3, r3
 8041008:	429a      	cmp	r2, r3
 804100a:	d106      	bne.n	804101a <HAL_ADC_ConfigChannel+0x33a>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 804100c:	687b      	ldr	r3, [r7, #4]
 804100e:	681b      	ldr	r3, [r3, #0]
 8041010:	2200      	movs	r2, #0
 8041012:	2103      	movs	r1, #3
 8041014:	4618      	mov	r0, r3
 8041016:	f7ff fbeb 	bl	80407f0 <LL_ADC_SetOffsetState>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 804101a:	687b      	ldr	r3, [r7, #4]
 804101c:	681b      	ldr	r3, [r3, #0]
 804101e:	4618      	mov	r0, r3
 8041020:	f7ff fcd4 	bl	80409cc <LL_ADC_IsEnabled>
 8041024:	4603      	mov	r3, r0
 8041026:	2b00      	cmp	r3, #0
 8041028:	f040 81a6 	bne.w	8041378 <HAL_ADC_ConfigChannel+0x698>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 804102c:	687b      	ldr	r3, [r7, #4]
 804102e:	6818      	ldr	r0, [r3, #0]
 8041030:	683b      	ldr	r3, [r7, #0]
 8041032:	6819      	ldr	r1, [r3, #0]
 8041034:	683b      	ldr	r3, [r7, #0]
 8041036:	68db      	ldr	r3, [r3, #12]
 8041038:	461a      	mov	r2, r3
 804103a:	f7ff fc55 	bl	80408e8 <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 804103e:	683b      	ldr	r3, [r7, #0]
 8041040:	68db      	ldr	r3, [r3, #12]
 8041042:	4aae      	ldr	r2, [pc, #696]	; (80412fc <HAL_ADC_ConfigChannel+0x61c>)
 8041044:	4293      	cmp	r3, r2
 8041046:	f040 80fd 	bne.w	8041244 <HAL_ADC_ConfigChannel+0x564>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 804104a:	687b      	ldr	r3, [r7, #4]
 804104c:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 804104e:	683b      	ldr	r3, [r7, #0]
 8041050:	681b      	ldr	r3, [r3, #0]
 8041052:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8041056:	2b00      	cmp	r3, #0
 8041058:	d10b      	bne.n	8041072 <HAL_ADC_ConfigChannel+0x392>
 804105a:	683b      	ldr	r3, [r7, #0]
 804105c:	681b      	ldr	r3, [r3, #0]
 804105e:	0e9b      	lsrs	r3, r3, #26
 8041060:	3301      	adds	r3, #1
 8041062:	f003 031f 	and.w	r3, r3, #31
 8041066:	2b09      	cmp	r3, #9
 8041068:	bf94      	ite	ls
 804106a:	2301      	movls	r3, #1
 804106c:	2300      	movhi	r3, #0
 804106e:	b2db      	uxtb	r3, r3
 8041070:	e012      	b.n	8041098 <HAL_ADC_ConfigChannel+0x3b8>
 8041072:	683b      	ldr	r3, [r7, #0]
 8041074:	681b      	ldr	r3, [r3, #0]
 8041076:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8041078:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 804107a:	fa93 f3a3 	rbit	r3, r3
 804107e:	63fb      	str	r3, [r7, #60]	; 0x3c
  return result;
 8041080:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8041082:	fab3 f383 	clz	r3, r3
 8041086:	b2db      	uxtb	r3, r3
 8041088:	3301      	adds	r3, #1
 804108a:	f003 031f 	and.w	r3, r3, #31
 804108e:	2b09      	cmp	r3, #9
 8041090:	bf94      	ite	ls
 8041092:	2301      	movls	r3, #1
 8041094:	2300      	movhi	r3, #0
 8041096:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8041098:	2b00      	cmp	r3, #0
 804109a:	d064      	beq.n	8041166 <HAL_ADC_ConfigChannel+0x486>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 804109c:	683b      	ldr	r3, [r7, #0]
 804109e:	681b      	ldr	r3, [r3, #0]
 80410a0:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80410a4:	2b00      	cmp	r3, #0
 80410a6:	d107      	bne.n	80410b8 <HAL_ADC_ConfigChannel+0x3d8>
 80410a8:	683b      	ldr	r3, [r7, #0]
 80410aa:	681b      	ldr	r3, [r3, #0]
 80410ac:	0e9b      	lsrs	r3, r3, #26
 80410ae:	3301      	adds	r3, #1
 80410b0:	069b      	lsls	r3, r3, #26
 80410b2:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80410b6:	e00e      	b.n	80410d6 <HAL_ADC_ConfigChannel+0x3f6>
 80410b8:	683b      	ldr	r3, [r7, #0]
 80410ba:	681b      	ldr	r3, [r3, #0]
 80410bc:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80410be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80410c0:	fa93 f3a3 	rbit	r3, r3
 80410c4:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 80410c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80410c8:	fab3 f383 	clz	r3, r3
 80410cc:	b2db      	uxtb	r3, r3
 80410ce:	3301      	adds	r3, #1
 80410d0:	069b      	lsls	r3, r3, #26
 80410d2:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80410d6:	683b      	ldr	r3, [r7, #0]
 80410d8:	681b      	ldr	r3, [r3, #0]
 80410da:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80410de:	2b00      	cmp	r3, #0
 80410e0:	d109      	bne.n	80410f6 <HAL_ADC_ConfigChannel+0x416>
 80410e2:	683b      	ldr	r3, [r7, #0]
 80410e4:	681b      	ldr	r3, [r3, #0]
 80410e6:	0e9b      	lsrs	r3, r3, #26
 80410e8:	3301      	adds	r3, #1
 80410ea:	f003 031f 	and.w	r3, r3, #31
 80410ee:	2101      	movs	r1, #1
 80410f0:	fa01 f303 	lsl.w	r3, r1, r3
 80410f4:	e010      	b.n	8041118 <HAL_ADC_ConfigChannel+0x438>
 80410f6:	683b      	ldr	r3, [r7, #0]
 80410f8:	681b      	ldr	r3, [r3, #0]
 80410fa:	633b      	str	r3, [r7, #48]	; 0x30
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80410fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80410fe:	fa93 f3a3 	rbit	r3, r3
 8041102:	62fb      	str	r3, [r7, #44]	; 0x2c
  return result;
 8041104:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8041106:	fab3 f383 	clz	r3, r3
 804110a:	b2db      	uxtb	r3, r3
 804110c:	3301      	adds	r3, #1
 804110e:	f003 031f 	and.w	r3, r3, #31
 8041112:	2101      	movs	r1, #1
 8041114:	fa01 f303 	lsl.w	r3, r1, r3
 8041118:	ea42 0103 	orr.w	r1, r2, r3
 804111c:	683b      	ldr	r3, [r7, #0]
 804111e:	681b      	ldr	r3, [r3, #0]
 8041120:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8041124:	2b00      	cmp	r3, #0
 8041126:	d10a      	bne.n	804113e <HAL_ADC_ConfigChannel+0x45e>
 8041128:	683b      	ldr	r3, [r7, #0]
 804112a:	681b      	ldr	r3, [r3, #0]
 804112c:	0e9b      	lsrs	r3, r3, #26
 804112e:	3301      	adds	r3, #1
 8041130:	f003 021f 	and.w	r2, r3, #31
 8041134:	4613      	mov	r3, r2
 8041136:	005b      	lsls	r3, r3, #1
 8041138:	4413      	add	r3, r2
 804113a:	051b      	lsls	r3, r3, #20
 804113c:	e011      	b.n	8041162 <HAL_ADC_ConfigChannel+0x482>
 804113e:	683b      	ldr	r3, [r7, #0]
 8041140:	681b      	ldr	r3, [r3, #0]
 8041142:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8041144:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8041146:	fa93 f3a3 	rbit	r3, r3
 804114a:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
 804114c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 804114e:	fab3 f383 	clz	r3, r3
 8041152:	b2db      	uxtb	r3, r3
 8041154:	3301      	adds	r3, #1
 8041156:	f003 021f 	and.w	r2, r3, #31
 804115a:	4613      	mov	r3, r2
 804115c:	005b      	lsls	r3, r3, #1
 804115e:	4413      	add	r3, r2
 8041160:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8041162:	430b      	orrs	r3, r1
 8041164:	e069      	b.n	804123a <HAL_ADC_ConfigChannel+0x55a>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8041166:	683b      	ldr	r3, [r7, #0]
 8041168:	681b      	ldr	r3, [r3, #0]
 804116a:	f3c3 0312 	ubfx	r3, r3, #0, #19
 804116e:	2b00      	cmp	r3, #0
 8041170:	d107      	bne.n	8041182 <HAL_ADC_ConfigChannel+0x4a2>
 8041172:	683b      	ldr	r3, [r7, #0]
 8041174:	681b      	ldr	r3, [r3, #0]
 8041176:	0e9b      	lsrs	r3, r3, #26
 8041178:	3301      	adds	r3, #1
 804117a:	069b      	lsls	r3, r3, #26
 804117c:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8041180:	e00e      	b.n	80411a0 <HAL_ADC_ConfigChannel+0x4c0>
 8041182:	683b      	ldr	r3, [r7, #0]
 8041184:	681b      	ldr	r3, [r3, #0]
 8041186:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8041188:	6a3b      	ldr	r3, [r7, #32]
 804118a:	fa93 f3a3 	rbit	r3, r3
 804118e:	61fb      	str	r3, [r7, #28]
  return result;
 8041190:	69fb      	ldr	r3, [r7, #28]
 8041192:	fab3 f383 	clz	r3, r3
 8041196:	b2db      	uxtb	r3, r3
 8041198:	3301      	adds	r3, #1
 804119a:	069b      	lsls	r3, r3, #26
 804119c:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 80411a0:	683b      	ldr	r3, [r7, #0]
 80411a2:	681b      	ldr	r3, [r3, #0]
 80411a4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80411a8:	2b00      	cmp	r3, #0
 80411aa:	d109      	bne.n	80411c0 <HAL_ADC_ConfigChannel+0x4e0>
 80411ac:	683b      	ldr	r3, [r7, #0]
 80411ae:	681b      	ldr	r3, [r3, #0]
 80411b0:	0e9b      	lsrs	r3, r3, #26
 80411b2:	3301      	adds	r3, #1
 80411b4:	f003 031f 	and.w	r3, r3, #31
 80411b8:	2101      	movs	r1, #1
 80411ba:	fa01 f303 	lsl.w	r3, r1, r3
 80411be:	e010      	b.n	80411e2 <HAL_ADC_ConfigChannel+0x502>
 80411c0:	683b      	ldr	r3, [r7, #0]
 80411c2:	681b      	ldr	r3, [r3, #0]
 80411c4:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80411c6:	69bb      	ldr	r3, [r7, #24]
 80411c8:	fa93 f3a3 	rbit	r3, r3
 80411cc:	617b      	str	r3, [r7, #20]
  return result;
 80411ce:	697b      	ldr	r3, [r7, #20]
 80411d0:	fab3 f383 	clz	r3, r3
 80411d4:	b2db      	uxtb	r3, r3
 80411d6:	3301      	adds	r3, #1
 80411d8:	f003 031f 	and.w	r3, r3, #31
 80411dc:	2101      	movs	r1, #1
 80411de:	fa01 f303 	lsl.w	r3, r1, r3
 80411e2:	ea42 0103 	orr.w	r1, r2, r3
 80411e6:	683b      	ldr	r3, [r7, #0]
 80411e8:	681b      	ldr	r3, [r3, #0]
 80411ea:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80411ee:	2b00      	cmp	r3, #0
 80411f0:	d10d      	bne.n	804120e <HAL_ADC_ConfigChannel+0x52e>
 80411f2:	683b      	ldr	r3, [r7, #0]
 80411f4:	681b      	ldr	r3, [r3, #0]
 80411f6:	0e9b      	lsrs	r3, r3, #26
 80411f8:	3301      	adds	r3, #1
 80411fa:	f003 021f 	and.w	r2, r3, #31
 80411fe:	4613      	mov	r3, r2
 8041200:	005b      	lsls	r3, r3, #1
 8041202:	4413      	add	r3, r2
 8041204:	3b1e      	subs	r3, #30
 8041206:	051b      	lsls	r3, r3, #20
 8041208:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 804120c:	e014      	b.n	8041238 <HAL_ADC_ConfigChannel+0x558>
 804120e:	683b      	ldr	r3, [r7, #0]
 8041210:	681b      	ldr	r3, [r3, #0]
 8041212:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8041214:	693b      	ldr	r3, [r7, #16]
 8041216:	fa93 f3a3 	rbit	r3, r3
 804121a:	60fb      	str	r3, [r7, #12]
  return result;
 804121c:	68fb      	ldr	r3, [r7, #12]
 804121e:	fab3 f383 	clz	r3, r3
 8041222:	b2db      	uxtb	r3, r3
 8041224:	3301      	adds	r3, #1
 8041226:	f003 021f 	and.w	r2, r3, #31
 804122a:	4613      	mov	r3, r2
 804122c:	005b      	lsls	r3, r3, #1
 804122e:	4413      	add	r3, r2
 8041230:	3b1e      	subs	r3, #30
 8041232:	051b      	lsls	r3, r3, #20
 8041234:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8041238:	430b      	orrs	r3, r1
 804123a:	683a      	ldr	r2, [r7, #0]
 804123c:	6892      	ldr	r2, [r2, #8]
 804123e:	4619      	mov	r1, r3
 8041240:	f7ff fb2a 	bl	8040898 <LL_ADC_SetChannelSamplingTime>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8041244:	683b      	ldr	r3, [r7, #0]
 8041246:	681a      	ldr	r2, [r3, #0]
 8041248:	4b2d      	ldr	r3, [pc, #180]	; (8041300 <HAL_ADC_ConfigChannel+0x620>)
 804124a:	4013      	ands	r3, r2
 804124c:	2b00      	cmp	r3, #0
 804124e:	f000 8093 	beq.w	8041378 <HAL_ADC_ConfigChannel+0x698>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8041252:	482c      	ldr	r0, [pc, #176]	; (8041304 <HAL_ADC_ConfigChannel+0x624>)
 8041254:	f7ff fa88 	bl	8040768 <LL_ADC_GetCommonPathInternalCh>
 8041258:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 804125c:	482a      	ldr	r0, [pc, #168]	; (8041308 <HAL_ADC_ConfigChannel+0x628>)
 804125e:	f7ff fbb5 	bl	80409cc <LL_ADC_IsEnabled>
 8041262:	4604      	mov	r4, r0
 8041264:	4829      	ldr	r0, [pc, #164]	; (804130c <HAL_ADC_ConfigChannel+0x62c>)
 8041266:	f7ff fbb1 	bl	80409cc <LL_ADC_IsEnabled>
 804126a:	4603      	mov	r3, r0
 804126c:	4323      	orrs	r3, r4
 804126e:	2b00      	cmp	r3, #0
 8041270:	d16f      	bne.n	8041352 <HAL_ADC_ConfigChannel+0x672>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8041272:	683b      	ldr	r3, [r7, #0]
 8041274:	681b      	ldr	r3, [r3, #0]
 8041276:	4a26      	ldr	r2, [pc, #152]	; (8041310 <HAL_ADC_ConfigChannel+0x630>)
 8041278:	4293      	cmp	r3, r2
 804127a:	d126      	bne.n	80412ca <HAL_ADC_ConfigChannel+0x5ea>
 804127c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8041280:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8041284:	2b00      	cmp	r3, #0
 8041286:	d120      	bne.n	80412ca <HAL_ADC_ConfigChannel+0x5ea>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8041288:	687b      	ldr	r3, [r7, #4]
 804128a:	681b      	ldr	r3, [r3, #0]
 804128c:	4a1e      	ldr	r2, [pc, #120]	; (8041308 <HAL_ADC_ConfigChannel+0x628>)
 804128e:	4293      	cmp	r3, r2
 8041290:	d172      	bne.n	8041378 <HAL_ADC_ConfigChannel+0x698>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 8041292:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8041296:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 804129a:	4619      	mov	r1, r3
 804129c:	4819      	ldr	r0, [pc, #100]	; (8041304 <HAL_ADC_ConfigChannel+0x624>)
 804129e:	f7ff fa50 	bl	8040742 <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80412a2:	4b1c      	ldr	r3, [pc, #112]	; (8041314 <HAL_ADC_ConfigChannel+0x634>)
 80412a4:	681b      	ldr	r3, [r3, #0]
 80412a6:	099b      	lsrs	r3, r3, #6
 80412a8:	4a1b      	ldr	r2, [pc, #108]	; (8041318 <HAL_ADC_ConfigChannel+0x638>)
 80412aa:	fba2 2303 	umull	r2, r3, r2, r3
 80412ae:	099a      	lsrs	r2, r3, #6
 80412b0:	4613      	mov	r3, r2
 80412b2:	005b      	lsls	r3, r3, #1
 80412b4:	4413      	add	r3, r2
 80412b6:	009b      	lsls	r3, r3, #2
 80412b8:	60bb      	str	r3, [r7, #8]
              while(wait_loop_index != 0UL)
 80412ba:	e002      	b.n	80412c2 <HAL_ADC_ConfigChannel+0x5e2>
              {
                wait_loop_index--;
 80412bc:	68bb      	ldr	r3, [r7, #8]
 80412be:	3b01      	subs	r3, #1
 80412c0:	60bb      	str	r3, [r7, #8]
              while(wait_loop_index != 0UL)
 80412c2:	68bb      	ldr	r3, [r7, #8]
 80412c4:	2b00      	cmp	r3, #0
 80412c6:	d1f9      	bne.n	80412bc <HAL_ADC_ConfigChannel+0x5dc>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80412c8:	e056      	b.n	8041378 <HAL_ADC_ConfigChannel+0x698>
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 80412ca:	683b      	ldr	r3, [r7, #0]
 80412cc:	681b      	ldr	r3, [r3, #0]
 80412ce:	4a13      	ldr	r2, [pc, #76]	; (804131c <HAL_ADC_ConfigChannel+0x63c>)
 80412d0:	4293      	cmp	r3, r2
 80412d2:	d125      	bne.n	8041320 <HAL_ADC_ConfigChannel+0x640>
 80412d4:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80412d8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80412dc:	2b00      	cmp	r3, #0
 80412de:	d11f      	bne.n	8041320 <HAL_ADC_ConfigChannel+0x640>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80412e0:	687b      	ldr	r3, [r7, #4]
 80412e2:	681b      	ldr	r3, [r3, #0]
 80412e4:	4a08      	ldr	r2, [pc, #32]	; (8041308 <HAL_ADC_ConfigChannel+0x628>)
 80412e6:	4293      	cmp	r3, r2
 80412e8:	d146      	bne.n	8041378 <HAL_ADC_ConfigChannel+0x698>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 80412ea:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80412ee:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80412f2:	4619      	mov	r1, r3
 80412f4:	4803      	ldr	r0, [pc, #12]	; (8041304 <HAL_ADC_ConfigChannel+0x624>)
 80412f6:	f7ff fa24 	bl	8040742 <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80412fa:	e03d      	b.n	8041378 <HAL_ADC_ConfigChannel+0x698>
 80412fc:	407f0000 	.word	0x407f0000
 8041300:	80080000 	.word	0x80080000
 8041304:	42028300 	.word	0x42028300
 8041308:	42028000 	.word	0x42028000
 804130c:	42028100 	.word	0x42028100
 8041310:	c7520000 	.word	0xc7520000
 8041314:	20018000 	.word	0x20018000
 8041318:	053e2d63 	.word	0x053e2d63
 804131c:	cb840000 	.word	0xcb840000
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8041320:	683b      	ldr	r3, [r7, #0]
 8041322:	681b      	ldr	r3, [r3, #0]
 8041324:	4a19      	ldr	r2, [pc, #100]	; (804138c <HAL_ADC_ConfigChannel+0x6ac>)
 8041326:	4293      	cmp	r3, r2
 8041328:	d126      	bne.n	8041378 <HAL_ADC_ConfigChannel+0x698>
 804132a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 804132e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8041332:	2b00      	cmp	r3, #0
 8041334:	d120      	bne.n	8041378 <HAL_ADC_ConfigChannel+0x698>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 8041336:	687b      	ldr	r3, [r7, #4]
 8041338:	681b      	ldr	r3, [r3, #0]
 804133a:	4a15      	ldr	r2, [pc, #84]	; (8041390 <HAL_ADC_ConfigChannel+0x6b0>)
 804133c:	4293      	cmp	r3, r2
 804133e:	d11b      	bne.n	8041378 <HAL_ADC_ConfigChannel+0x698>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 8041340:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8041344:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8041348:	4619      	mov	r1, r3
 804134a:	4812      	ldr	r0, [pc, #72]	; (8041394 <HAL_ADC_ConfigChannel+0x6b4>)
 804134c:	f7ff f9f9 	bl	8040742 <LL_ADC_SetCommonPathInternalCh>
 8041350:	e012      	b.n	8041378 <HAL_ADC_ConfigChannel+0x698>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8041352:	687b      	ldr	r3, [r7, #4]
 8041354:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041356:	f043 0220 	orr.w	r2, r3, #32
 804135a:	687b      	ldr	r3, [r7, #4]
 804135c:	659a      	str	r2, [r3, #88]	; 0x58

          tmp_hal_status = HAL_ERROR;
 804135e:	2301      	movs	r3, #1
 8041360:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
 8041364:	e008      	b.n	8041378 <HAL_ADC_ConfigChannel+0x698>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8041366:	687b      	ldr	r3, [r7, #4]
 8041368:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 804136a:	f043 0220 	orr.w	r2, r3, #32
 804136e:	687b      	ldr	r3, [r7, #4]
 8041370:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8041372:	2301      	movs	r3, #1
 8041374:	f887 3097 	strb.w	r3, [r7, #151]	; 0x97
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8041378:	687b      	ldr	r3, [r7, #4]
 804137a:	2200      	movs	r2, #0
 804137c:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
 8041380:	f897 3097 	ldrb.w	r3, [r7, #151]	; 0x97
}
 8041384:	4618      	mov	r0, r3
 8041386:	379c      	adds	r7, #156	; 0x9c
 8041388:	46bd      	mov	sp, r7
 804138a:	bd90      	pop	{r4, r7, pc}
 804138c:	80000001 	.word	0x80000001
 8041390:	42028000 	.word	0x42028000
 8041394:	42028300 	.word	0x42028300

08041398 <LL_ADC_IsEnabled>:
{
 8041398:	b480      	push	{r7}
 804139a:	b083      	sub	sp, #12
 804139c:	af00      	add	r7, sp, #0
 804139e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80413a0:	687b      	ldr	r3, [r7, #4]
 80413a2:	689b      	ldr	r3, [r3, #8]
 80413a4:	f003 0301 	and.w	r3, r3, #1
 80413a8:	2b01      	cmp	r3, #1
 80413aa:	d101      	bne.n	80413b0 <LL_ADC_IsEnabled+0x18>
 80413ac:	2301      	movs	r3, #1
 80413ae:	e000      	b.n	80413b2 <LL_ADC_IsEnabled+0x1a>
 80413b0:	2300      	movs	r3, #0
}
 80413b2:	4618      	mov	r0, r3
 80413b4:	370c      	adds	r7, #12
 80413b6:	46bd      	mov	sp, r7
 80413b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80413bc:	4770      	bx	lr

080413be <LL_ADC_REG_IsConversionOngoing>:
{
 80413be:	b480      	push	{r7}
 80413c0:	b083      	sub	sp, #12
 80413c2:	af00      	add	r7, sp, #0
 80413c4:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80413c6:	687b      	ldr	r3, [r7, #4]
 80413c8:	689b      	ldr	r3, [r3, #8]
 80413ca:	f003 0304 	and.w	r3, r3, #4
 80413ce:	2b04      	cmp	r3, #4
 80413d0:	d101      	bne.n	80413d6 <LL_ADC_REG_IsConversionOngoing+0x18>
 80413d2:	2301      	movs	r3, #1
 80413d4:	e000      	b.n	80413d8 <LL_ADC_REG_IsConversionOngoing+0x1a>
 80413d6:	2300      	movs	r3, #0
}
 80413d8:	4618      	mov	r0, r3
 80413da:	370c      	adds	r7, #12
 80413dc:	46bd      	mov	sp, r7
 80413de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80413e2:	4770      	bx	lr

080413e4 <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 80413e4:	b590      	push	{r4, r7, lr}
 80413e6:	b0a1      	sub	sp, #132	; 0x84
 80413e8:	af00      	add	r7, sp, #0
 80413ea:	6078      	str	r0, [r7, #4]
 80413ec:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80413ee:	2300      	movs	r3, #0
 80413f0:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
    assert_param(IS_ADC_DMA_ACCESS_MULTIMODE(multimode->DMAAccessMode));
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80413f4:	687b      	ldr	r3, [r7, #4]
 80413f6:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 80413fa:	2b01      	cmp	r3, #1
 80413fc:	d101      	bne.n	8041402 <HAL_ADCEx_MultiModeConfigChannel+0x1e>
 80413fe:	2302      	movs	r3, #2
 8041400:	e085      	b.n	804150e <HAL_ADCEx_MultiModeConfigChannel+0x12a>
 8041402:	687b      	ldr	r3, [r7, #4]
 8041404:	2201      	movs	r2, #1
 8041406:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 804140a:	687b      	ldr	r3, [r7, #4]
 804140c:	681b      	ldr	r3, [r3, #0]
 804140e:	4a42      	ldr	r2, [pc, #264]	; (8041518 <HAL_ADCEx_MultiModeConfigChannel+0x134>)
 8041410:	4293      	cmp	r3, r2
 8041412:	d102      	bne.n	804141a <HAL_ADCEx_MultiModeConfigChannel+0x36>
 8041414:	4b41      	ldr	r3, [pc, #260]	; (804151c <HAL_ADCEx_MultiModeConfigChannel+0x138>)
 8041416:	60fb      	str	r3, [r7, #12]
 8041418:	e001      	b.n	804141e <HAL_ADCEx_MultiModeConfigChannel+0x3a>
 804141a:	2300      	movs	r3, #0
 804141c:	60fb      	str	r3, [r7, #12]

  if (tmphadcSlave.Instance == NULL)
 804141e:	68fb      	ldr	r3, [r7, #12]
 8041420:	2b00      	cmp	r3, #0
 8041422:	d10b      	bne.n	804143c <HAL_ADCEx_MultiModeConfigChannel+0x58>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8041424:	687b      	ldr	r3, [r7, #4]
 8041426:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041428:	f043 0220 	orr.w	r2, r3, #32
 804142c:	687b      	ldr	r3, [r7, #4]
 804142e:	659a      	str	r2, [r3, #88]	; 0x58

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8041430:	687b      	ldr	r3, [r7, #4]
 8041432:	2200      	movs	r2, #0
 8041434:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

    return HAL_ERROR;
 8041438:	2301      	movs	r3, #1
 804143a:	e068      	b.n	804150e <HAL_ADCEx_MultiModeConfigChannel+0x12a>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Multimode DMA configuration                                           */
  /*  - Multimode DMA mode                                                    */
  tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
 804143c:	68fb      	ldr	r3, [r7, #12]
 804143e:	4618      	mov	r0, r3
 8041440:	f7ff ffbd 	bl	80413be <LL_ADC_REG_IsConversionOngoing>
 8041444:	67b8      	str	r0, [r7, #120]	; 0x78
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8041446:	687b      	ldr	r3, [r7, #4]
 8041448:	681b      	ldr	r3, [r3, #0]
 804144a:	4618      	mov	r0, r3
 804144c:	f7ff ffb7 	bl	80413be <LL_ADC_REG_IsConversionOngoing>
 8041450:	4603      	mov	r3, r0
 8041452:	2b00      	cmp	r3, #0
 8041454:	d14a      	bne.n	80414ec <HAL_ADCEx_MultiModeConfigChannel+0x108>
      && (tmphadcSlave_conversion_on_going == 0UL))
 8041456:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8041458:	2b00      	cmp	r3, #0
 804145a:	d147      	bne.n	80414ec <HAL_ADCEx_MultiModeConfigChannel+0x108>
  {
    /* Pointer to the common control register */
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
 804145c:	4b30      	ldr	r3, [pc, #192]	; (8041520 <HAL_ADCEx_MultiModeConfigChannel+0x13c>)
 804145e:	677b      	str	r3, [r7, #116]	; 0x74

    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8041460:	683b      	ldr	r3, [r7, #0]
 8041462:	681b      	ldr	r3, [r3, #0]
 8041464:	2b00      	cmp	r3, #0
 8041466:	d027      	beq.n	80414b8 <HAL_ADCEx_MultiModeConfigChannel+0xd4>
    {
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG,
 8041468:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 804146a:	689b      	ldr	r3, [r3, #8]
 804146c:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8041470:	683b      	ldr	r3, [r7, #0]
 8041472:	6859      	ldr	r1, [r3, #4]
 8041474:	687b      	ldr	r3, [r7, #4]
 8041476:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 804147a:	035b      	lsls	r3, r3, #13
 804147c:	430b      	orrs	r3, r1
 804147e:	431a      	orrs	r2, r3
 8041480:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8041482:	609a      	str	r2, [r3, #8]
      /*      from 1 to 10 clock cycles for 10 bits,                              */
      /*      from 1 to 8 clock cycles for 8 bits                                 */
      /*      from 1 to 6 clock cycles for 6 bits                                 */
      /*    If a higher delay is selected, it will be clipped to maximum delay    */
      /*    range                                                                 */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8041484:	4824      	ldr	r0, [pc, #144]	; (8041518 <HAL_ADCEx_MultiModeConfigChannel+0x134>)
 8041486:	f7ff ff87 	bl	8041398 <LL_ADC_IsEnabled>
 804148a:	4604      	mov	r4, r0
 804148c:	4823      	ldr	r0, [pc, #140]	; (804151c <HAL_ADCEx_MultiModeConfigChannel+0x138>)
 804148e:	f7ff ff83 	bl	8041398 <LL_ADC_IsEnabled>
 8041492:	4603      	mov	r3, r0
 8041494:	4323      	orrs	r3, r4
 8041496:	2b00      	cmp	r3, #0
 8041498:	d132      	bne.n	8041500 <HAL_ADCEx_MultiModeConfigChannel+0x11c>
      {
        MODIFY_REG(tmpADC_Common->CCR,
 804149a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 804149c:	689b      	ldr	r3, [r3, #8]
 804149e:	f423 6371 	bic.w	r3, r3, #3856	; 0xf10
 80414a2:	f023 030f 	bic.w	r3, r3, #15
 80414a6:	683a      	ldr	r2, [r7, #0]
 80414a8:	6811      	ldr	r1, [r2, #0]
 80414aa:	683a      	ldr	r2, [r7, #0]
 80414ac:	6892      	ldr	r2, [r2, #8]
 80414ae:	430a      	orrs	r2, r1
 80414b0:	431a      	orrs	r2, r3
 80414b2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80414b4:	609a      	str	r2, [r3, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80414b6:	e023      	b.n	8041500 <HAL_ADCEx_MultiModeConfigChannel+0x11c>
                  );
      }
    }
    else /* ADC_MODE_INDEPENDENT */
    {
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA | ADC_CCR_DMACFG);
 80414b8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80414ba:	689b      	ldr	r3, [r3, #8]
 80414bc:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 80414c0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80414c2:	609a      	str	r2, [r3, #8]

      /* Parameters that can be updated only when ADC is disabled:                */
      /*  - Multimode mode selection                                              */
      /*  - Multimode delay                                                       */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80414c4:	4814      	ldr	r0, [pc, #80]	; (8041518 <HAL_ADCEx_MultiModeConfigChannel+0x134>)
 80414c6:	f7ff ff67 	bl	8041398 <LL_ADC_IsEnabled>
 80414ca:	4604      	mov	r4, r0
 80414cc:	4813      	ldr	r0, [pc, #76]	; (804151c <HAL_ADCEx_MultiModeConfigChannel+0x138>)
 80414ce:	f7ff ff63 	bl	8041398 <LL_ADC_IsEnabled>
 80414d2:	4603      	mov	r3, r0
 80414d4:	4323      	orrs	r3, r4
 80414d6:	2b00      	cmp	r3, #0
 80414d8:	d112      	bne.n	8041500 <HAL_ADCEx_MultiModeConfigChannel+0x11c>
      {
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 80414da:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80414dc:	689b      	ldr	r3, [r3, #8]
 80414de:	f423 6371 	bic.w	r3, r3, #3856	; 0xf10
 80414e2:	f023 030f 	bic.w	r3, r3, #15
 80414e6:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80414e8:	6093      	str	r3, [r2, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80414ea:	e009      	b.n	8041500 <HAL_ADCEx_MultiModeConfigChannel+0x11c>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80414ec:	687b      	ldr	r3, [r7, #4]
 80414ee:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80414f0:	f043 0220 	orr.w	r2, r3, #32
 80414f4:	687b      	ldr	r3, [r7, #4]
 80414f6:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 80414f8:	2301      	movs	r3, #1
 80414fa:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 80414fe:	e000      	b.n	8041502 <HAL_ADCEx_MultiModeConfigChannel+0x11e>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8041500:	bf00      	nop
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8041502:	687b      	ldr	r3, [r7, #4]
 8041504:	2200      	movs	r2, #0
 8041506:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
 804150a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
}
 804150e:	4618      	mov	r0, r3
 8041510:	3784      	adds	r7, #132	; 0x84
 8041512:	46bd      	mov	sp, r7
 8041514:	bd90      	pop	{r4, r7, pc}
 8041516:	bf00      	nop
 8041518:	42028000 	.word	0x42028000
 804151c:	42028100 	.word	0x42028100
 8041520:	42028300 	.word	0x42028300

08041524 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8041524:	b480      	push	{r7}
 8041526:	b085      	sub	sp, #20
 8041528:	af00      	add	r7, sp, #0
 804152a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 804152c:	687b      	ldr	r3, [r7, #4]
 804152e:	f003 0307 	and.w	r3, r3, #7
 8041532:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8041534:	4b0c      	ldr	r3, [pc, #48]	; (8041568 <__NVIC_SetPriorityGrouping+0x44>)
 8041536:	68db      	ldr	r3, [r3, #12]
 8041538:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 804153a:	68ba      	ldr	r2, [r7, #8]
 804153c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8041540:	4013      	ands	r3, r2
 8041542:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priority group */
 8041544:	68fb      	ldr	r3, [r7, #12]
 8041546:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8041548:	68bb      	ldr	r3, [r7, #8]
 804154a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 804154c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8041550:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8041554:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8041556:	4a04      	ldr	r2, [pc, #16]	; (8041568 <__NVIC_SetPriorityGrouping+0x44>)
 8041558:	68bb      	ldr	r3, [r7, #8]
 804155a:	60d3      	str	r3, [r2, #12]
}
 804155c:	bf00      	nop
 804155e:	3714      	adds	r7, #20
 8041560:	46bd      	mov	sp, r7
 8041562:	f85d 7b04 	ldr.w	r7, [sp], #4
 8041566:	4770      	bx	lr
 8041568:	e000ed00 	.word	0xe000ed00

0804156c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 804156c:	b480      	push	{r7}
 804156e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8041570:	4b04      	ldr	r3, [pc, #16]	; (8041584 <__NVIC_GetPriorityGrouping+0x18>)
 8041572:	68db      	ldr	r3, [r3, #12]
 8041574:	0a1b      	lsrs	r3, r3, #8
 8041576:	f003 0307 	and.w	r3, r3, #7
}
 804157a:	4618      	mov	r0, r3
 804157c:	46bd      	mov	sp, r7
 804157e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8041582:	4770      	bx	lr
 8041584:	e000ed00 	.word	0xe000ed00

08041588 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8041588:	b480      	push	{r7}
 804158a:	b083      	sub	sp, #12
 804158c:	af00      	add	r7, sp, #0
 804158e:	4603      	mov	r3, r0
 8041590:	6039      	str	r1, [r7, #0]
 8041592:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8041594:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8041598:	2b00      	cmp	r3, #0
 804159a:	db0a      	blt.n	80415b2 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804159c:	683b      	ldr	r3, [r7, #0]
 804159e:	b2da      	uxtb	r2, r3
 80415a0:	490c      	ldr	r1, [pc, #48]	; (80415d4 <__NVIC_SetPriority+0x4c>)
 80415a2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80415a6:	0152      	lsls	r2, r2, #5
 80415a8:	b2d2      	uxtb	r2, r2
 80415aa:	440b      	add	r3, r1
 80415ac:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80415b0:	e00a      	b.n	80415c8 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80415b2:	683b      	ldr	r3, [r7, #0]
 80415b4:	b2da      	uxtb	r2, r3
 80415b6:	4908      	ldr	r1, [pc, #32]	; (80415d8 <__NVIC_SetPriority+0x50>)
 80415b8:	79fb      	ldrb	r3, [r7, #7]
 80415ba:	f003 030f 	and.w	r3, r3, #15
 80415be:	3b04      	subs	r3, #4
 80415c0:	0152      	lsls	r2, r2, #5
 80415c2:	b2d2      	uxtb	r2, r2
 80415c4:	440b      	add	r3, r1
 80415c6:	761a      	strb	r2, [r3, #24]
}
 80415c8:	bf00      	nop
 80415ca:	370c      	adds	r7, #12
 80415cc:	46bd      	mov	sp, r7
 80415ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80415d2:	4770      	bx	lr
 80415d4:	e000e100 	.word	0xe000e100
 80415d8:	e000ed00 	.word	0xe000ed00

080415dc <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80415dc:	b480      	push	{r7}
 80415de:	b089      	sub	sp, #36	; 0x24
 80415e0:	af00      	add	r7, sp, #0
 80415e2:	60f8      	str	r0, [r7, #12]
 80415e4:	60b9      	str	r1, [r7, #8]
 80415e6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80415e8:	68fb      	ldr	r3, [r7, #12]
 80415ea:	f003 0307 	and.w	r3, r3, #7
 80415ee:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80415f0:	69fb      	ldr	r3, [r7, #28]
 80415f2:	f1c3 0307 	rsb	r3, r3, #7
 80415f6:	2b03      	cmp	r3, #3
 80415f8:	bf28      	it	cs
 80415fa:	2303      	movcs	r3, #3
 80415fc:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80415fe:	69fb      	ldr	r3, [r7, #28]
 8041600:	3303      	adds	r3, #3
 8041602:	2b06      	cmp	r3, #6
 8041604:	d902      	bls.n	804160c <NVIC_EncodePriority+0x30>
 8041606:	69fb      	ldr	r3, [r7, #28]
 8041608:	3b04      	subs	r3, #4
 804160a:	e000      	b.n	804160e <NVIC_EncodePriority+0x32>
 804160c:	2300      	movs	r3, #0
 804160e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8041610:	f04f 32ff 	mov.w	r2, #4294967295
 8041614:	69bb      	ldr	r3, [r7, #24]
 8041616:	fa02 f303 	lsl.w	r3, r2, r3
 804161a:	43da      	mvns	r2, r3
 804161c:	68bb      	ldr	r3, [r7, #8]
 804161e:	401a      	ands	r2, r3
 8041620:	697b      	ldr	r3, [r7, #20]
 8041622:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8041624:	f04f 31ff 	mov.w	r1, #4294967295
 8041628:	697b      	ldr	r3, [r7, #20]
 804162a:	fa01 f303 	lsl.w	r3, r1, r3
 804162e:	43d9      	mvns	r1, r3
 8041630:	687b      	ldr	r3, [r7, #4]
 8041632:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8041634:	4313      	orrs	r3, r2
         );
}
 8041636:	4618      	mov	r0, r3
 8041638:	3724      	adds	r7, #36	; 0x24
 804163a:	46bd      	mov	sp, r7
 804163c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8041640:	4770      	bx	lr
	...

08041644 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8041644:	b580      	push	{r7, lr}
 8041646:	b082      	sub	sp, #8
 8041648:	af00      	add	r7, sp, #0
 804164a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 804164c:	687b      	ldr	r3, [r7, #4]
 804164e:	3b01      	subs	r3, #1
 8041650:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8041654:	d301      	bcc.n	804165a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8041656:	2301      	movs	r3, #1
 8041658:	e00f      	b.n	804167a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804165a:	4a0a      	ldr	r2, [pc, #40]	; (8041684 <SysTick_Config+0x40>)
 804165c:	687b      	ldr	r3, [r7, #4]
 804165e:	3b01      	subs	r3, #1
 8041660:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8041662:	2107      	movs	r1, #7
 8041664:	f04f 30ff 	mov.w	r0, #4294967295
 8041668:	f7ff ff8e 	bl	8041588 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 804166c:	4b05      	ldr	r3, [pc, #20]	; (8041684 <SysTick_Config+0x40>)
 804166e:	2200      	movs	r2, #0
 8041670:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8041672:	4b04      	ldr	r3, [pc, #16]	; (8041684 <SysTick_Config+0x40>)
 8041674:	2207      	movs	r2, #7
 8041676:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8041678:	2300      	movs	r3, #0
}
 804167a:	4618      	mov	r0, r3
 804167c:	3708      	adds	r7, #8
 804167e:	46bd      	mov	sp, r7
 8041680:	bd80      	pop	{r7, pc}
 8041682:	bf00      	nop
 8041684:	e000e010 	.word	0xe000e010

08041688 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8041688:	b580      	push	{r7, lr}
 804168a:	b082      	sub	sp, #8
 804168c:	af00      	add	r7, sp, #0
 804168e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8041690:	6878      	ldr	r0, [r7, #4]
 8041692:	f7ff ff47 	bl	8041524 <__NVIC_SetPriorityGrouping>
}
 8041696:	bf00      	nop
 8041698:	3708      	adds	r7, #8
 804169a:	46bd      	mov	sp, r7
 804169c:	bd80      	pop	{r7, pc}

0804169e <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 804169e:	b580      	push	{r7, lr}
 80416a0:	b086      	sub	sp, #24
 80416a2:	af00      	add	r7, sp, #0
 80416a4:	4603      	mov	r3, r0
 80416a6:	60b9      	str	r1, [r7, #8]
 80416a8:	607a      	str	r2, [r7, #4]
 80416aa:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 80416ac:	f7ff ff5e 	bl	804156c <__NVIC_GetPriorityGrouping>
 80416b0:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80416b2:	687a      	ldr	r2, [r7, #4]
 80416b4:	68b9      	ldr	r1, [r7, #8]
 80416b6:	6978      	ldr	r0, [r7, #20]
 80416b8:	f7ff ff90 	bl	80415dc <NVIC_EncodePriority>
 80416bc:	4602      	mov	r2, r0
 80416be:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80416c2:	4611      	mov	r1, r2
 80416c4:	4618      	mov	r0, r3
 80416c6:	f7ff ff5f 	bl	8041588 <__NVIC_SetPriority>
}
 80416ca:	bf00      	nop
 80416cc:	3718      	adds	r7, #24
 80416ce:	46bd      	mov	sp, r7
 80416d0:	bd80      	pop	{r7, pc}

080416d2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80416d2:	b580      	push	{r7, lr}
 80416d4:	b082      	sub	sp, #8
 80416d6:	af00      	add	r7, sp, #0
 80416d8:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 80416da:	6878      	ldr	r0, [r7, #4]
 80416dc:	f7ff ffb2 	bl	8041644 <SysTick_Config>
 80416e0:	4603      	mov	r3, r0
}
 80416e2:	4618      	mov	r0, r3
 80416e4:	3708      	adds	r7, #8
 80416e6:	46bd      	mov	sp, r7
 80416e8:	bd80      	pop	{r7, pc}
	...

080416ec <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80416ec:	b480      	push	{r7}
 80416ee:	b087      	sub	sp, #28
 80416f0:	af00      	add	r7, sp, #0
 80416f2:	6078      	str	r0, [r7, #4]
 80416f4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0U;
 80416f6:	2300      	movs	r3, #0
 80416f8:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 80416fa:	e158      	b.n	80419ae <HAL_GPIO_Init+0x2c2>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 80416fc:	683b      	ldr	r3, [r7, #0]
 80416fe:	681a      	ldr	r2, [r3, #0]
 8041700:	2101      	movs	r1, #1
 8041702:	697b      	ldr	r3, [r7, #20]
 8041704:	fa01 f303 	lsl.w	r3, r1, r3
 8041708:	4013      	ands	r3, r2
 804170a:	60fb      	str	r3, [r7, #12]

    if(iocurrent != 0U)
 804170c:	68fb      	ldr	r3, [r7, #12]
 804170e:	2b00      	cmp	r3, #0
 8041710:	f000 814a 	beq.w	80419a8 <HAL_GPIO_Init+0x2bc>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8041714:	683b      	ldr	r3, [r7, #0]
 8041716:	685b      	ldr	r3, [r3, #4]
 8041718:	2b01      	cmp	r3, #1
 804171a:	d00b      	beq.n	8041734 <HAL_GPIO_Init+0x48>
 804171c:	683b      	ldr	r3, [r7, #0]
 804171e:	685b      	ldr	r3, [r3, #4]
 8041720:	2b02      	cmp	r3, #2
 8041722:	d007      	beq.n	8041734 <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8041724:	683b      	ldr	r3, [r7, #0]
 8041726:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8041728:	2b11      	cmp	r3, #17
 804172a:	d003      	beq.n	8041734 <HAL_GPIO_Init+0x48>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 804172c:	683b      	ldr	r3, [r7, #0]
 804172e:	685b      	ldr	r3, [r3, #4]
 8041730:	2b12      	cmp	r3, #18
 8041732:	d130      	bne.n	8041796 <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8041734:	687b      	ldr	r3, [r7, #4]
 8041736:	689b      	ldr	r3, [r3, #8]
 8041738:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 804173a:	697b      	ldr	r3, [r7, #20]
 804173c:	005b      	lsls	r3, r3, #1
 804173e:	2203      	movs	r2, #3
 8041740:	fa02 f303 	lsl.w	r3, r2, r3
 8041744:	43db      	mvns	r3, r3
 8041746:	693a      	ldr	r2, [r7, #16]
 8041748:	4013      	ands	r3, r2
 804174a:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 804174c:	683b      	ldr	r3, [r7, #0]
 804174e:	68da      	ldr	r2, [r3, #12]
 8041750:	697b      	ldr	r3, [r7, #20]
 8041752:	005b      	lsls	r3, r3, #1
 8041754:	fa02 f303 	lsl.w	r3, r2, r3
 8041758:	693a      	ldr	r2, [r7, #16]
 804175a:	4313      	orrs	r3, r2
 804175c:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 804175e:	687b      	ldr	r3, [r7, #4]
 8041760:	693a      	ldr	r2, [r7, #16]
 8041762:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8041764:	687b      	ldr	r3, [r7, #4]
 8041766:	685b      	ldr	r3, [r3, #4]
 8041768:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 804176a:	2201      	movs	r2, #1
 804176c:	697b      	ldr	r3, [r7, #20]
 804176e:	fa02 f303 	lsl.w	r3, r2, r3
 8041772:	43db      	mvns	r3, r3
 8041774:	693a      	ldr	r2, [r7, #16]
 8041776:	4013      	ands	r3, r2
 8041778:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 804177a:	683b      	ldr	r3, [r7, #0]
 804177c:	685b      	ldr	r3, [r3, #4]
 804177e:	091b      	lsrs	r3, r3, #4
 8041780:	f003 0201 	and.w	r2, r3, #1
 8041784:	697b      	ldr	r3, [r7, #20]
 8041786:	fa02 f303 	lsl.w	r3, r2, r3
 804178a:	693a      	ldr	r2, [r7, #16]
 804178c:	4313      	orrs	r3, r2
 804178e:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 8041790:	687b      	ldr	r3, [r7, #4]
 8041792:	693a      	ldr	r2, [r7, #16]
 8041794:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8041796:	687b      	ldr	r3, [r7, #4]
 8041798:	68db      	ldr	r3, [r3, #12]
 804179a:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 804179c:	697b      	ldr	r3, [r7, #20]
 804179e:	005b      	lsls	r3, r3, #1
 80417a0:	2203      	movs	r2, #3
 80417a2:	fa02 f303 	lsl.w	r3, r2, r3
 80417a6:	43db      	mvns	r3, r3
 80417a8:	693a      	ldr	r2, [r7, #16]
 80417aa:	4013      	ands	r3, r2
 80417ac:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80417ae:	683b      	ldr	r3, [r7, #0]
 80417b0:	689a      	ldr	r2, [r3, #8]
 80417b2:	697b      	ldr	r3, [r7, #20]
 80417b4:	005b      	lsls	r3, r3, #1
 80417b6:	fa02 f303 	lsl.w	r3, r2, r3
 80417ba:	693a      	ldr	r2, [r7, #16]
 80417bc:	4313      	orrs	r3, r2
 80417be:	613b      	str	r3, [r7, #16]
      GPIOx->PUPDR = temp;
 80417c0:	687b      	ldr	r3, [r7, #4]
 80417c2:	693a      	ldr	r2, [r7, #16]
 80417c4:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80417c6:	683b      	ldr	r3, [r7, #0]
 80417c8:	685b      	ldr	r3, [r3, #4]
 80417ca:	2b02      	cmp	r3, #2
 80417cc:	d003      	beq.n	80417d6 <HAL_GPIO_Init+0xea>
 80417ce:	683b      	ldr	r3, [r7, #0]
 80417d0:	685b      	ldr	r3, [r3, #4]
 80417d2:	2b12      	cmp	r3, #18
 80417d4:	d123      	bne.n	804181e <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80417d6:	697b      	ldr	r3, [r7, #20]
 80417d8:	08da      	lsrs	r2, r3, #3
 80417da:	687b      	ldr	r3, [r7, #4]
 80417dc:	3208      	adds	r2, #8
 80417de:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80417e2:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 80417e4:	697b      	ldr	r3, [r7, #20]
 80417e6:	f003 0307 	and.w	r3, r3, #7
 80417ea:	009b      	lsls	r3, r3, #2
 80417ec:	220f      	movs	r2, #15
 80417ee:	fa02 f303 	lsl.w	r3, r2, r3
 80417f2:	43db      	mvns	r3, r3
 80417f4:	693a      	ldr	r2, [r7, #16]
 80417f6:	4013      	ands	r3, r2
 80417f8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80417fa:	683b      	ldr	r3, [r7, #0]
 80417fc:	691a      	ldr	r2, [r3, #16]
 80417fe:	697b      	ldr	r3, [r7, #20]
 8041800:	f003 0307 	and.w	r3, r3, #7
 8041804:	009b      	lsls	r3, r3, #2
 8041806:	fa02 f303 	lsl.w	r3, r2, r3
 804180a:	693a      	ldr	r2, [r7, #16]
 804180c:	4313      	orrs	r3, r2
 804180e:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 8041810:	697b      	ldr	r3, [r7, #20]
 8041812:	08da      	lsrs	r2, r3, #3
 8041814:	687b      	ldr	r3, [r7, #4]
 8041816:	3208      	adds	r2, #8
 8041818:	6939      	ldr	r1, [r7, #16]
 804181a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 804181e:	687b      	ldr	r3, [r7, #4]
 8041820:	681b      	ldr	r3, [r3, #0]
 8041822:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8041824:	697b      	ldr	r3, [r7, #20]
 8041826:	005b      	lsls	r3, r3, #1
 8041828:	2203      	movs	r2, #3
 804182a:	fa02 f303 	lsl.w	r3, r2, r3
 804182e:	43db      	mvns	r3, r3
 8041830:	693a      	ldr	r2, [r7, #16]
 8041832:	4013      	ands	r3, r2
 8041834:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8041836:	683b      	ldr	r3, [r7, #0]
 8041838:	685b      	ldr	r3, [r3, #4]
 804183a:	f003 0203 	and.w	r2, r3, #3
 804183e:	697b      	ldr	r3, [r7, #20]
 8041840:	005b      	lsls	r3, r3, #1
 8041842:	fa02 f303 	lsl.w	r3, r2, r3
 8041846:	693a      	ldr	r2, [r7, #16]
 8041848:	4313      	orrs	r3, r2
 804184a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 804184c:	687b      	ldr	r3, [r7, #4]
 804184e:	693a      	ldr	r2, [r7, #16]
 8041850:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8041852:	683b      	ldr	r3, [r7, #0]
 8041854:	685b      	ldr	r3, [r3, #4]
 8041856:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 804185a:	2b00      	cmp	r3, #0
 804185c:	f000 80a4 	beq.w	80419a8 <HAL_GPIO_Init+0x2bc>
      {
        temp = EXTI->EXTICR[position >> 2U];
 8041860:	4a5a      	ldr	r2, [pc, #360]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 8041862:	697b      	ldr	r3, [r7, #20]
 8041864:	089b      	lsrs	r3, r3, #2
 8041866:	3318      	adds	r3, #24
 8041868:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804186c:	613b      	str	r3, [r7, #16]
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 804186e:	697b      	ldr	r3, [r7, #20]
 8041870:	f003 0303 	and.w	r3, r3, #3
 8041874:	00db      	lsls	r3, r3, #3
 8041876:	220f      	movs	r2, #15
 8041878:	fa02 f303 	lsl.w	r3, r2, r3
 804187c:	43db      	mvns	r3, r3
 804187e:	693a      	ldr	r2, [r7, #16]
 8041880:	4013      	ands	r3, r2
 8041882:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 8041884:	687b      	ldr	r3, [r7, #4]
 8041886:	4a52      	ldr	r2, [pc, #328]	; (80419d0 <HAL_GPIO_Init+0x2e4>)
 8041888:	4293      	cmp	r3, r2
 804188a:	d025      	beq.n	80418d8 <HAL_GPIO_Init+0x1ec>
 804188c:	687b      	ldr	r3, [r7, #4]
 804188e:	4a51      	ldr	r2, [pc, #324]	; (80419d4 <HAL_GPIO_Init+0x2e8>)
 8041890:	4293      	cmp	r3, r2
 8041892:	d01f      	beq.n	80418d4 <HAL_GPIO_Init+0x1e8>
 8041894:	687b      	ldr	r3, [r7, #4]
 8041896:	4a50      	ldr	r2, [pc, #320]	; (80419d8 <HAL_GPIO_Init+0x2ec>)
 8041898:	4293      	cmp	r3, r2
 804189a:	d019      	beq.n	80418d0 <HAL_GPIO_Init+0x1e4>
 804189c:	687b      	ldr	r3, [r7, #4]
 804189e:	4a4f      	ldr	r2, [pc, #316]	; (80419dc <HAL_GPIO_Init+0x2f0>)
 80418a0:	4293      	cmp	r3, r2
 80418a2:	d013      	beq.n	80418cc <HAL_GPIO_Init+0x1e0>
 80418a4:	687b      	ldr	r3, [r7, #4]
 80418a6:	4a4e      	ldr	r2, [pc, #312]	; (80419e0 <HAL_GPIO_Init+0x2f4>)
 80418a8:	4293      	cmp	r3, r2
 80418aa:	d00d      	beq.n	80418c8 <HAL_GPIO_Init+0x1dc>
 80418ac:	687b      	ldr	r3, [r7, #4]
 80418ae:	4a4d      	ldr	r2, [pc, #308]	; (80419e4 <HAL_GPIO_Init+0x2f8>)
 80418b0:	4293      	cmp	r3, r2
 80418b2:	d007      	beq.n	80418c4 <HAL_GPIO_Init+0x1d8>
 80418b4:	687b      	ldr	r3, [r7, #4]
 80418b6:	4a4c      	ldr	r2, [pc, #304]	; (80419e8 <HAL_GPIO_Init+0x2fc>)
 80418b8:	4293      	cmp	r3, r2
 80418ba:	d101      	bne.n	80418c0 <HAL_GPIO_Init+0x1d4>
 80418bc:	2306      	movs	r3, #6
 80418be:	e00c      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418c0:	2307      	movs	r3, #7
 80418c2:	e00a      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418c4:	2305      	movs	r3, #5
 80418c6:	e008      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418c8:	2304      	movs	r3, #4
 80418ca:	e006      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418cc:	2303      	movs	r3, #3
 80418ce:	e004      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418d0:	2302      	movs	r3, #2
 80418d2:	e002      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418d4:	2301      	movs	r3, #1
 80418d6:	e000      	b.n	80418da <HAL_GPIO_Init+0x1ee>
 80418d8:	2300      	movs	r3, #0
 80418da:	697a      	ldr	r2, [r7, #20]
 80418dc:	f002 0203 	and.w	r2, r2, #3
 80418e0:	00d2      	lsls	r2, r2, #3
 80418e2:	4093      	lsls	r3, r2
 80418e4:	693a      	ldr	r2, [r7, #16]
 80418e6:	4313      	orrs	r3, r2
 80418e8:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2U] = temp;
 80418ea:	4938      	ldr	r1, [pc, #224]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 80418ec:	697b      	ldr	r3, [r7, #20]
 80418ee:	089b      	lsrs	r3, r3, #2
 80418f0:	3318      	adds	r3, #24
 80418f2:	693a      	ldr	r2, [r7, #16]
 80418f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 80418f8:	4b34      	ldr	r3, [pc, #208]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 80418fa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80418fe:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8041900:	68fb      	ldr	r3, [r7, #12]
 8041902:	43db      	mvns	r3, r3
 8041904:	693a      	ldr	r2, [r7, #16]
 8041906:	4013      	ands	r3, r2
 8041908:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 804190a:	683b      	ldr	r3, [r7, #0]
 804190c:	685b      	ldr	r3, [r3, #4]
 804190e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8041912:	2b00      	cmp	r3, #0
 8041914:	d003      	beq.n	804191e <HAL_GPIO_Init+0x232>
        {
          temp |= iocurrent;
 8041916:	693a      	ldr	r2, [r7, #16]
 8041918:	68fb      	ldr	r3, [r7, #12]
 804191a:	4313      	orrs	r3, r2
 804191c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 804191e:	4a2b      	ldr	r2, [pc, #172]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 8041920:	693b      	ldr	r3, [r7, #16]
 8041922:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

        temp = EXTI->EMR1;
 8041926:	4b29      	ldr	r3, [pc, #164]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 8041928:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 804192c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 804192e:	68fb      	ldr	r3, [r7, #12]
 8041930:	43db      	mvns	r3, r3
 8041932:	693a      	ldr	r2, [r7, #16]
 8041934:	4013      	ands	r3, r2
 8041936:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8041938:	683b      	ldr	r3, [r7, #0]
 804193a:	685b      	ldr	r3, [r3, #4]
 804193c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8041940:	2b00      	cmp	r3, #0
 8041942:	d003      	beq.n	804194c <HAL_GPIO_Init+0x260>
        {
          temp |= iocurrent;
 8041944:	693a      	ldr	r2, [r7, #16]
 8041946:	68fb      	ldr	r3, [r7, #12]
 8041948:	4313      	orrs	r3, r2
 804194a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 804194c:	4a1f      	ldr	r2, [pc, #124]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 804194e:	693b      	ldr	r3, [r7, #16]
 8041950:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8041954:	4b1d      	ldr	r3, [pc, #116]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 8041956:	681b      	ldr	r3, [r3, #0]
 8041958:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 804195a:	68fb      	ldr	r3, [r7, #12]
 804195c:	43db      	mvns	r3, r3
 804195e:	693a      	ldr	r2, [r7, #16]
 8041960:	4013      	ands	r3, r2
 8041962:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8041964:	683b      	ldr	r3, [r7, #0]
 8041966:	685b      	ldr	r3, [r3, #4]
 8041968:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 804196c:	2b00      	cmp	r3, #0
 804196e:	d003      	beq.n	8041978 <HAL_GPIO_Init+0x28c>
        {
          temp |= iocurrent;
 8041970:	693a      	ldr	r2, [r7, #16]
 8041972:	68fb      	ldr	r3, [r7, #12]
 8041974:	4313      	orrs	r3, r2
 8041976:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8041978:	4a14      	ldr	r2, [pc, #80]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 804197a:	693b      	ldr	r3, [r7, #16]
 804197c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 804197e:	4b13      	ldr	r3, [pc, #76]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 8041980:	685b      	ldr	r3, [r3, #4]
 8041982:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8041984:	68fb      	ldr	r3, [r7, #12]
 8041986:	43db      	mvns	r3, r3
 8041988:	693a      	ldr	r2, [r7, #16]
 804198a:	4013      	ands	r3, r2
 804198c:	613b      	str	r3, [r7, #16]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 804198e:	683b      	ldr	r3, [r7, #0]
 8041990:	685b      	ldr	r3, [r3, #4]
 8041992:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8041996:	2b00      	cmp	r3, #0
 8041998:	d003      	beq.n	80419a2 <HAL_GPIO_Init+0x2b6>
        {
          temp |= iocurrent;
 804199a:	693a      	ldr	r2, [r7, #16]
 804199c:	68fb      	ldr	r3, [r7, #12]
 804199e:	4313      	orrs	r3, r2
 80419a0:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 80419a2:	4a0a      	ldr	r2, [pc, #40]	; (80419cc <HAL_GPIO_Init+0x2e0>)
 80419a4:	693b      	ldr	r3, [r7, #16]
 80419a6:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
 80419a8:	697b      	ldr	r3, [r7, #20]
 80419aa:	3301      	adds	r3, #1
 80419ac:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0U)
 80419ae:	683b      	ldr	r3, [r7, #0]
 80419b0:	681a      	ldr	r2, [r3, #0]
 80419b2:	697b      	ldr	r3, [r7, #20]
 80419b4:	fa22 f303 	lsr.w	r3, r2, r3
 80419b8:	2b00      	cmp	r3, #0
 80419ba:	f47f ae9f 	bne.w	80416fc <HAL_GPIO_Init+0x10>
  }
}
 80419be:	bf00      	nop
 80419c0:	371c      	adds	r7, #28
 80419c2:	46bd      	mov	sp, r7
 80419c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80419c8:	4770      	bx	lr
 80419ca:	bf00      	nop
 80419cc:	4002f400 	.word	0x4002f400
 80419d0:	42020000 	.word	0x42020000
 80419d4:	42020400 	.word	0x42020400
 80419d8:	42020800 	.word	0x42020800
 80419dc:	42020c00 	.word	0x42020c00
 80419e0:	42021000 	.word	0x42021000
 80419e4:	42021400 	.word	0x42021400
 80419e8:	42021800 	.word	0x42021800

080419ec <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 80419ec:	b480      	push	{r7}
 80419ee:	b085      	sub	sp, #20
 80419f0:	af00      	add	r7, sp, #0
 80419f2:	6078      	str	r0, [r7, #4]
 80419f4:	460b      	mov	r3, r1
 80419f6:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != 0U)
 80419f8:	687b      	ldr	r3, [r7, #4]
 80419fa:	691a      	ldr	r2, [r3, #16]
 80419fc:	887b      	ldrh	r3, [r7, #2]
 80419fe:	4013      	ands	r3, r2
 8041a00:	2b00      	cmp	r3, #0
 8041a02:	d002      	beq.n	8041a0a <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 8041a04:	2301      	movs	r3, #1
 8041a06:	73fb      	strb	r3, [r7, #15]
 8041a08:	e001      	b.n	8041a0e <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8041a0a:	2300      	movs	r3, #0
 8041a0c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8041a0e:	7bfb      	ldrb	r3, [r7, #15]
}
 8041a10:	4618      	mov	r0, r3
 8041a12:	3714      	adds	r7, #20
 8041a14:	46bd      	mov	sp, r7
 8041a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8041a1a:	4770      	bx	lr

08041a1c <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8041a1c:	b580      	push	{r7, lr}
 8041a1e:	b088      	sub	sp, #32
 8041a20:	af00      	add	r7, sp, #0
 8041a22:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8041a24:	2300      	movs	r3, #0
 8041a26:	77fb      	strb	r3, [r7, #31]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8041a28:	2300      	movs	r3, #0
 8041a2a:	77bb      	strb	r3, [r7, #30]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8041a2c:	687b      	ldr	r3, [r7, #4]
 8041a2e:	681b      	ldr	r3, [r3, #0]
 8041a30:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8041a34:	2b00      	cmp	r3, #0
 8041a36:	d03d      	beq.n	8041ab4 <HAL_RCCEx_PeriphCLKConfig+0x98>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
 8041a38:	687b      	ldr	r3, [r7, #4]
 8041a3a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8041a3c:	2b40      	cmp	r3, #64	; 0x40
 8041a3e:	d00b      	beq.n	8041a58 <HAL_RCCEx_PeriphCLKConfig+0x3c>
 8041a40:	2b40      	cmp	r3, #64	; 0x40
 8041a42:	d804      	bhi.n	8041a4e <HAL_RCCEx_PeriphCLKConfig+0x32>
 8041a44:	2b00      	cmp	r3, #0
 8041a46:	d00e      	beq.n	8041a66 <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8041a48:	2b20      	cmp	r3, #32
 8041a4a:	d015      	beq.n	8041a78 <HAL_RCCEx_PeriphCLKConfig+0x5c>
 8041a4c:	e01d      	b.n	8041a8a <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8041a4e:	2b60      	cmp	r3, #96	; 0x60
 8041a50:	d01e      	beq.n	8041a90 <HAL_RCCEx_PeriphCLKConfig+0x74>
 8041a52:	2b80      	cmp	r3, #128	; 0x80
 8041a54:	d01c      	beq.n	8041a90 <HAL_RCCEx_PeriphCLKConfig+0x74>
 8041a56:	e018      	b.n	8041a8a <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated from System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8041a58:	4b84      	ldr	r3, [pc, #528]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041a5a:	68db      	ldr	r3, [r3, #12]
 8041a5c:	4a83      	ldr	r2, [pc, #524]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041a5e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8041a62:	60d3      	str	r3, [r2, #12]
        /* SAI1 clock source config set later after clock selection check */
        break;
 8041a64:	e015      	b.n	8041a92 <HAL_RCCEx_PeriphCLKConfig+0x76>

      case RCC_SAI1CLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for SAI1*/
        /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8041a66:	687b      	ldr	r3, [r7, #4]
 8041a68:	3304      	adds	r3, #4
 8041a6a:	2100      	movs	r1, #0
 8041a6c:	4618      	mov	r0, r3
 8041a6e:	f000 fb3f 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8041a72:	4603      	mov	r3, r0
 8041a74:	77fb      	strb	r3, [r7, #31]
        /* SAI1 clock source config set later after clock selection check */
        break;
 8041a76:	e00c      	b.n	8041a92 <HAL_RCCEx_PeriphCLKConfig+0x76>

      case RCC_SAI1CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI1*/
        /* PLLSAI2 input clock, parameters M, N & P configuration clock output (PLLSAI2ClockOut) */
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8041a78:	687b      	ldr	r3, [r7, #4]
 8041a7a:	3320      	adds	r3, #32
 8041a7c:	2100      	movs	r1, #0
 8041a7e:	4618      	mov	r0, r3
 8041a80:	f000 fc08 	bl	8042294 <RCCEx_PLLSAI2_Config>
 8041a84:	4603      	mov	r3, r0
 8041a86:	77fb      	strb	r3, [r7, #31]
        /* SAI1 clock source config set later after clock selection check */
        break;
 8041a88:	e003      	b.n	8041a92 <HAL_RCCEx_PeriphCLKConfig+0x76>
      case RCC_SAI1CLKSOURCE_HSI:      /* HSI is used as source of SAI1 clock*/
        /* SAI1 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8041a8a:	2301      	movs	r3, #1
 8041a8c:	77fb      	strb	r3, [r7, #31]
        break;
 8041a8e:	e000      	b.n	8041a92 <HAL_RCCEx_PeriphCLKConfig+0x76>
        break;
 8041a90:	bf00      	nop
    }

    if (ret == HAL_OK)
 8041a92:	7ffb      	ldrb	r3, [r7, #31]
 8041a94:	2b00      	cmp	r3, #0
 8041a96:	d10b      	bne.n	8041ab0 <HAL_RCCEx_PeriphCLKConfig+0x94>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8041a98:	4b74      	ldr	r3, [pc, #464]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041a9a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8041a9e:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
 8041aa2:	687b      	ldr	r3, [r7, #4]
 8041aa4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8041aa6:	4971      	ldr	r1, [pc, #452]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041aa8:	4313      	orrs	r3, r2
 8041aaa:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8041aae:	e001      	b.n	8041ab4 <HAL_RCCEx_PeriphCLKConfig+0x98>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8041ab0:	7ffb      	ldrb	r3, [r7, #31]
 8041ab2:	77bb      	strb	r3, [r7, #30]
    }
  }

  /*-------------------------- SAI2 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8041ab4:	687b      	ldr	r3, [r7, #4]
 8041ab6:	681b      	ldr	r3, [r3, #0]
 8041ab8:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8041abc:	2b00      	cmp	r3, #0
 8041abe:	d042      	beq.n	8041b46 <HAL_RCCEx_PeriphCLKConfig+0x12a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLK(PeriphClkInit->Sai2ClockSelection));

    switch (PeriphClkInit->Sai2ClockSelection)
 8041ac0:	687b      	ldr	r3, [r7, #4]
 8041ac2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8041ac4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8041ac8:	d00f      	beq.n	8041aea <HAL_RCCEx_PeriphCLKConfig+0xce>
 8041aca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8041ace:	d805      	bhi.n	8041adc <HAL_RCCEx_PeriphCLKConfig+0xc0>
 8041ad0:	2b00      	cmp	r3, #0
 8041ad2:	d011      	beq.n	8041af8 <HAL_RCCEx_PeriphCLKConfig+0xdc>
 8041ad4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8041ad8:	d017      	beq.n	8041b0a <HAL_RCCEx_PeriphCLKConfig+0xee>
 8041ada:	e01f      	b.n	8041b1c <HAL_RCCEx_PeriphCLKConfig+0x100>
 8041adc:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8041ae0:	d01f      	beq.n	8041b22 <HAL_RCCEx_PeriphCLKConfig+0x106>
 8041ae2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8041ae6:	d01c      	beq.n	8041b22 <HAL_RCCEx_PeriphCLKConfig+0x106>
 8041ae8:	e018      	b.n	8041b1c <HAL_RCCEx_PeriphCLKConfig+0x100>
    {
      case RCC_SAI2CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated from System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8041aea:	4b60      	ldr	r3, [pc, #384]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041aec:	68db      	ldr	r3, [r3, #12]
 8041aee:	4a5f      	ldr	r2, [pc, #380]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041af0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8041af4:	60d3      	str	r3, [r2, #12]
        /* SAI2 clock source config set later after clock selection check */
        break;
 8041af6:	e015      	b.n	8041b24 <HAL_RCCEx_PeriphCLKConfig+0x108>

      case RCC_SAI2CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI2*/
        /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8041af8:	687b      	ldr	r3, [r7, #4]
 8041afa:	3304      	adds	r3, #4
 8041afc:	2100      	movs	r1, #0
 8041afe:	4618      	mov	r0, r3
 8041b00:	f000 faf6 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8041b04:	4603      	mov	r3, r0
 8041b06:	77fb      	strb	r3, [r7, #31]
        /* SAI2 clock source config set later after clock selection check */
        break;
 8041b08:	e00c      	b.n	8041b24 <HAL_RCCEx_PeriphCLKConfig+0x108>

      case RCC_SAI2CLKSOURCE_PLLSAI2:  /* PLLSAI2 is used as clock source for SAI2*/
        /* PLLSAI2 input clock, parameters M, N & P configuration and clock output (PLLSAI2ClockOut) */
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8041b0a:	687b      	ldr	r3, [r7, #4]
 8041b0c:	3320      	adds	r3, #32
 8041b0e:	2100      	movs	r1, #0
 8041b10:	4618      	mov	r0, r3
 8041b12:	f000 fbbf 	bl	8042294 <RCCEx_PLLSAI2_Config>
 8041b16:	4603      	mov	r3, r0
 8041b18:	77fb      	strb	r3, [r7, #31]
        /* SAI2 clock source config set later after clock selection check */
        break;
 8041b1a:	e003      	b.n	8041b24 <HAL_RCCEx_PeriphCLKConfig+0x108>
      case RCC_SAI2CLKSOURCE_HSI:      /* HSI is used as source of SAI2 clock*/
        /* SAI2 clock source config set later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8041b1c:	2301      	movs	r3, #1
 8041b1e:	77fb      	strb	r3, [r7, #31]
        break;
 8041b20:	e000      	b.n	8041b24 <HAL_RCCEx_PeriphCLKConfig+0x108>
        break;
 8041b22:	bf00      	nop
    }

    if (ret == HAL_OK)
 8041b24:	7ffb      	ldrb	r3, [r7, #31]
 8041b26:	2b00      	cmp	r3, #0
 8041b28:	d10b      	bne.n	8041b42 <HAL_RCCEx_PeriphCLKConfig+0x126>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8041b2a:	4b50      	ldr	r3, [pc, #320]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041b2c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8041b30:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8041b34:	687b      	ldr	r3, [r7, #4]
 8041b36:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8041b38:	494c      	ldr	r1, [pc, #304]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041b3a:	4313      	orrs	r3, r2
 8041b3c:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
 8041b40:	e001      	b.n	8041b46 <HAL_RCCEx_PeriphCLKConfig+0x12a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8041b42:	7ffb      	ldrb	r3, [r7, #31]
 8041b44:	77bb      	strb	r3, [r7, #30]
    }
  }

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8041b46:	687b      	ldr	r3, [r7, #4]
 8041b48:	681b      	ldr	r3, [r3, #0]
 8041b4a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8041b4e:	2b00      	cmp	r3, #0
 8041b50:	f000 809b 	beq.w	8041c8a <HAL_RCCEx_PeriphCLKConfig+0x26e>
  {
    FlagStatus       pwrclkchanged = RESET;
 8041b54:	2300      	movs	r3, #0
 8041b56:	75fb      	strb	r3, [r7, #23]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8041b58:	4b44      	ldr	r3, [pc, #272]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041b5a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041b5c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8041b60:	2b00      	cmp	r3, #0
 8041b62:	d10d      	bne.n	8041b80 <HAL_RCCEx_PeriphCLKConfig+0x164>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8041b64:	4b41      	ldr	r3, [pc, #260]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041b66:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041b68:	4a40      	ldr	r2, [pc, #256]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041b6a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8041b6e:	6593      	str	r3, [r2, #88]	; 0x58
 8041b70:	4b3e      	ldr	r3, [pc, #248]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041b72:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041b74:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8041b78:	60fb      	str	r3, [r7, #12]
 8041b7a:	68fb      	ldr	r3, [r7, #12]
      pwrclkchanged = SET;
 8041b7c:	2301      	movs	r3, #1
 8041b7e:	75fb      	strb	r3, [r7, #23]
    }

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8041b80:	4b3b      	ldr	r3, [pc, #236]	; (8041c70 <HAL_RCCEx_PeriphCLKConfig+0x254>)
 8041b82:	681b      	ldr	r3, [r3, #0]
 8041b84:	4a3a      	ldr	r2, [pc, #232]	; (8041c70 <HAL_RCCEx_PeriphCLKConfig+0x254>)
 8041b86:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8041b8a:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8041b8c:	f7fe fd98 	bl	80406c0 <HAL_GetTick>
 8041b90:	6138      	str	r0, [r7, #16]

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8041b92:	e009      	b.n	8041ba8 <HAL_RCCEx_PeriphCLKConfig+0x18c>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8041b94:	f7fe fd94 	bl	80406c0 <HAL_GetTick>
 8041b98:	4602      	mov	r2, r0
 8041b9a:	693b      	ldr	r3, [r7, #16]
 8041b9c:	1ad3      	subs	r3, r2, r3
 8041b9e:	2b02      	cmp	r3, #2
 8041ba0:	d902      	bls.n	8041ba8 <HAL_RCCEx_PeriphCLKConfig+0x18c>
      {
        ret = HAL_TIMEOUT;
 8041ba2:	2303      	movs	r3, #3
 8041ba4:	77fb      	strb	r3, [r7, #31]
        break;
 8041ba6:	e005      	b.n	8041bb4 <HAL_RCCEx_PeriphCLKConfig+0x198>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8041ba8:	4b31      	ldr	r3, [pc, #196]	; (8041c70 <HAL_RCCEx_PeriphCLKConfig+0x254>)
 8041baa:	681b      	ldr	r3, [r3, #0]
 8041bac:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8041bb0:	2b00      	cmp	r3, #0
 8041bb2:	d0ef      	beq.n	8041b94 <HAL_RCCEx_PeriphCLKConfig+0x178>
      }
    }

    if (ret == HAL_OK)
 8041bb4:	7ffb      	ldrb	r3, [r7, #31]
 8041bb6:	2b00      	cmp	r3, #0
 8041bb8:	d15c      	bne.n	8041c74 <HAL_RCCEx_PeriphCLKConfig+0x258>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8041bba:	4b2c      	ldr	r3, [pc, #176]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041bbc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041bc0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8041bc4:	61bb      	str	r3, [r7, #24]

      if ((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8041bc6:	69bb      	ldr	r3, [r7, #24]
 8041bc8:	2b00      	cmp	r3, #0
 8041bca:	d01f      	beq.n	8041c0c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
 8041bcc:	687b      	ldr	r3, [r7, #4]
 8041bce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041bd2:	69ba      	ldr	r2, [r7, #24]
 8041bd4:	429a      	cmp	r2, r3
 8041bd6:	d019      	beq.n	8041c0c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8041bd8:	4b24      	ldr	r3, [pc, #144]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041bda:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041bde:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8041be2:	61bb      	str	r3, [r7, #24]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8041be4:	4b21      	ldr	r3, [pc, #132]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041be6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041bea:	4a20      	ldr	r2, [pc, #128]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041bec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8041bf0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8041bf4:	4b1d      	ldr	r3, [pc, #116]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041bf6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041bfa:	4a1c      	ldr	r2, [pc, #112]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041bfc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8041c00:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 8041c04:	4a19      	ldr	r2, [pc, #100]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041c06:	69bb      	ldr	r3, [r7, #24]
 8041c08:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8041c0c:	69bb      	ldr	r3, [r7, #24]
 8041c0e:	f003 0301 	and.w	r3, r3, #1
 8041c12:	2b00      	cmp	r3, #0
 8041c14:	d016      	beq.n	8041c44 <HAL_RCCEx_PeriphCLKConfig+0x228>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8041c16:	f7fe fd53 	bl	80406c0 <HAL_GetTick>
 8041c1a:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8041c1c:	e00b      	b.n	8041c36 <HAL_RCCEx_PeriphCLKConfig+0x21a>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8041c1e:	f7fe fd4f 	bl	80406c0 <HAL_GetTick>
 8041c22:	4602      	mov	r2, r0
 8041c24:	693b      	ldr	r3, [r7, #16]
 8041c26:	1ad3      	subs	r3, r2, r3
 8041c28:	f241 3288 	movw	r2, #5000	; 0x1388
 8041c2c:	4293      	cmp	r3, r2
 8041c2e:	d902      	bls.n	8041c36 <HAL_RCCEx_PeriphCLKConfig+0x21a>
          {
            ret = HAL_TIMEOUT;
 8041c30:	2303      	movs	r3, #3
 8041c32:	77fb      	strb	r3, [r7, #31]
            break;
 8041c34:	e006      	b.n	8041c44 <HAL_RCCEx_PeriphCLKConfig+0x228>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8041c36:	4b0d      	ldr	r3, [pc, #52]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041c38:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041c3c:	f003 0302 	and.w	r3, r3, #2
 8041c40:	2b00      	cmp	r3, #0
 8041c42:	d0ec      	beq.n	8041c1e <HAL_RCCEx_PeriphCLKConfig+0x202>
          }
        }
      }

      if (ret == HAL_OK)
 8041c44:	7ffb      	ldrb	r3, [r7, #31]
 8041c46:	2b00      	cmp	r3, #0
 8041c48:	d10c      	bne.n	8041c64 <HAL_RCCEx_PeriphCLKConfig+0x248>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8041c4a:	4b08      	ldr	r3, [pc, #32]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041c4c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041c50:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8041c54:	687b      	ldr	r3, [r7, #4]
 8041c56:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8041c5a:	4904      	ldr	r1, [pc, #16]	; (8041c6c <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8041c5c:	4313      	orrs	r3, r2
 8041c5e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
 8041c62:	e009      	b.n	8041c78 <HAL_RCCEx_PeriphCLKConfig+0x25c>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8041c64:	7ffb      	ldrb	r3, [r7, #31]
 8041c66:	77bb      	strb	r3, [r7, #30]
 8041c68:	e006      	b.n	8041c78 <HAL_RCCEx_PeriphCLKConfig+0x25c>
 8041c6a:	bf00      	nop
 8041c6c:	40021000 	.word	0x40021000
 8041c70:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8041c74:	7ffb      	ldrb	r3, [r7, #31]
 8041c76:	77bb      	strb	r3, [r7, #30]
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8041c78:	7dfb      	ldrb	r3, [r7, #23]
 8041c7a:	2b01      	cmp	r3, #1
 8041c7c:	d105      	bne.n	8041c8a <HAL_RCCEx_PeriphCLKConfig+0x26e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8041c7e:	4bae      	ldr	r3, [pc, #696]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041c80:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041c82:	4aad      	ldr	r2, [pc, #692]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041c84:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8041c88:	6593      	str	r3, [r2, #88]	; 0x58
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8041c8a:	687b      	ldr	r3, [r7, #4]
 8041c8c:	681b      	ldr	r3, [r3, #0]
 8041c8e:	f003 0301 	and.w	r3, r3, #1
 8041c92:	2b00      	cmp	r3, #0
 8041c94:	d00a      	beq.n	8041cac <HAL_RCCEx_PeriphCLKConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8041c96:	4ba8      	ldr	r3, [pc, #672]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041c98:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041c9c:	f023 0203 	bic.w	r2, r3, #3
 8041ca0:	687b      	ldr	r3, [r7, #4]
 8041ca2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8041ca4:	49a4      	ldr	r1, [pc, #656]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041ca6:	4313      	orrs	r3, r2
 8041ca8:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8041cac:	687b      	ldr	r3, [r7, #4]
 8041cae:	681b      	ldr	r3, [r3, #0]
 8041cb0:	f003 0302 	and.w	r3, r3, #2
 8041cb4:	2b00      	cmp	r3, #0
 8041cb6:	d00a      	beq.n	8041cce <HAL_RCCEx_PeriphCLKConfig+0x2b2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8041cb8:	4b9f      	ldr	r3, [pc, #636]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041cba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041cbe:	f023 020c 	bic.w	r2, r3, #12
 8041cc2:	687b      	ldr	r3, [r7, #4]
 8041cc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8041cc6:	499c      	ldr	r1, [pc, #624]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041cc8:	4313      	orrs	r3, r2
 8041cca:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8041cce:	687b      	ldr	r3, [r7, #4]
 8041cd0:	681b      	ldr	r3, [r3, #0]
 8041cd2:	f003 0304 	and.w	r3, r3, #4
 8041cd6:	2b00      	cmp	r3, #0
 8041cd8:	d00a      	beq.n	8041cf0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8041cda:	4b97      	ldr	r3, [pc, #604]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041cdc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041ce0:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8041ce4:	687b      	ldr	r3, [r7, #4]
 8041ce6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8041ce8:	4993      	ldr	r1, [pc, #588]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041cea:	4313      	orrs	r3, r2
 8041cec:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- UART4 clock source configuration --------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8041cf0:	687b      	ldr	r3, [r7, #4]
 8041cf2:	681b      	ldr	r3, [r3, #0]
 8041cf4:	f003 0308 	and.w	r3, r3, #8
 8041cf8:	2b00      	cmp	r3, #0
 8041cfa:	d00a      	beq.n	8041d12 <HAL_RCCEx_PeriphCLKConfig+0x2f6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8041cfc:	4b8e      	ldr	r3, [pc, #568]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041cfe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041d02:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 8041d06:	687b      	ldr	r3, [r7, #4]
 8041d08:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8041d0a:	498b      	ldr	r1, [pc, #556]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d0c:	4313      	orrs	r3, r2
 8041d0e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- UART5 clock source configuration --------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8041d12:	687b      	ldr	r3, [r7, #4]
 8041d14:	681b      	ldr	r3, [r3, #0]
 8041d16:	f003 0310 	and.w	r3, r3, #16
 8041d1a:	2b00      	cmp	r3, #0
 8041d1c:	d00a      	beq.n	8041d34 <HAL_RCCEx_PeriphCLKConfig+0x318>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8041d1e:	4b86      	ldr	r3, [pc, #536]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d20:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041d24:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8041d28:	687b      	ldr	r3, [r7, #4]
 8041d2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8041d2c:	4982      	ldr	r1, [pc, #520]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d2e:	4313      	orrs	r3, r2
 8041d30:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8041d34:	687b      	ldr	r3, [r7, #4]
 8041d36:	681b      	ldr	r3, [r3, #0]
 8041d38:	f003 0320 	and.w	r3, r3, #32
 8041d3c:	2b00      	cmp	r3, #0
 8041d3e:	d00a      	beq.n	8041d56 <HAL_RCCEx_PeriphCLKConfig+0x33a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUART1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8041d40:	4b7d      	ldr	r3, [pc, #500]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d42:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041d46:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8041d4a:	687b      	ldr	r3, [r7, #4]
 8041d4c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8041d4e:	497a      	ldr	r1, [pc, #488]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d50:	4313      	orrs	r3, r2
 8041d52:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8041d56:	687b      	ldr	r3, [r7, #4]
 8041d58:	681b      	ldr	r3, [r3, #0]
 8041d5a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8041d5e:	2b00      	cmp	r3, #0
 8041d60:	d00a      	beq.n	8041d78 <HAL_RCCEx_PeriphCLKConfig+0x35c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8041d62:	4b75      	ldr	r3, [pc, #468]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d64:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041d68:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 8041d6c:	687b      	ldr	r3, [r7, #4]
 8041d6e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8041d70:	4971      	ldr	r1, [pc, #452]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d72:	4313      	orrs	r3, r2
 8041d74:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8041d78:	687b      	ldr	r3, [r7, #4]
 8041d7a:	681b      	ldr	r3, [r3, #0]
 8041d7c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8041d80:	2b00      	cmp	r3, #0
 8041d82:	d00a      	beq.n	8041d9a <HAL_RCCEx_PeriphCLKConfig+0x37e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8041d84:	4b6c      	ldr	r3, [pc, #432]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d86:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041d8a:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8041d8e:	687b      	ldr	r3, [r7, #4]
 8041d90:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8041d92:	4969      	ldr	r1, [pc, #420]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041d94:	4313      	orrs	r3, r2
 8041d96:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 8041d9a:	687b      	ldr	r3, [r7, #4]
 8041d9c:	681b      	ldr	r3, [r3, #0]
 8041d9e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8041da2:	2b00      	cmp	r3, #0
 8041da4:	d00a      	beq.n	8041dbc <HAL_RCCEx_PeriphCLKConfig+0x3a0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLK(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 8041da6:	4b64      	ldr	r3, [pc, #400]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041da8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041dac:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8041db0:	687b      	ldr	r3, [r7, #4]
 8041db2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8041db4:	4960      	ldr	r1, [pc, #384]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041db6:	4313      	orrs	r3, r2
 8041db8:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- FDCAN kernel clock source configuration -------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == (RCC_PERIPHCLK_FDCAN))
 8041dbc:	687b      	ldr	r3, [r7, #4]
 8041dbe:	681b      	ldr	r3, [r3, #0]
 8041dc0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8041dc4:	2b00      	cmp	r3, #0
 8041dc6:	d02f      	beq.n	8041e28 <HAL_RCCEx_PeriphCLKConfig+0x40c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLK(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN kernel clock source */
    switch (PeriphClkInit->FdcanClockSelection)
 8041dc8:	687b      	ldr	r3, [r7, #4]
 8041dca:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8041dcc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8041dd0:	d005      	beq.n	8041dde <HAL_RCCEx_PeriphCLKConfig+0x3c2>
 8041dd2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8041dd6:	d009      	beq.n	8041dec <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 8041dd8:	2b00      	cmp	r3, #0
 8041dda:	d013      	beq.n	8041e04 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
 8041ddc:	e00f      	b.n	8041dfe <HAL_RCCEx_PeriphCLKConfig+0x3e2>
        /* FDCAN kernel clock source config set later after clock selection check */
        break;

      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN kernel clock*/
        /* Enable PLL48M1CLK output clock generated from System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8041dde:	4b56      	ldr	r3, [pc, #344]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041de0:	68db      	ldr	r3, [r3, #12]
 8041de2:	4a55      	ldr	r2, [pc, #340]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041de4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8041de8:	60d3      	str	r3, [r2, #12]
        /* FDCAN kernel clock source config set later after clock selection check */
        break;
 8041dea:	e00c      	b.n	8041e06 <HAL_RCCEx_PeriphCLKConfig+0x3ea>

      case RCC_FDCANCLKSOURCE_PLLSAI1:  /* PLLSAI1 is used as clock source for FDCAN kernel clock*/
        /* PLLSAI1 input clock, parameters M, N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8041dec:	687b      	ldr	r3, [r7, #4]
 8041dee:	3304      	adds	r3, #4
 8041df0:	2100      	movs	r1, #0
 8041df2:	4618      	mov	r0, r3
 8041df4:	f000 f97c 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8041df8:	4603      	mov	r3, r0
 8041dfa:	77fb      	strb	r3, [r7, #31]
        /* FDCAN kernel clock source config set later after clock selection check */
        break;
 8041dfc:	e003      	b.n	8041e06 <HAL_RCCEx_PeriphCLKConfig+0x3ea>

      default:
        ret = HAL_ERROR;
 8041dfe:	2301      	movs	r3, #1
 8041e00:	77fb      	strb	r3, [r7, #31]
        break;
 8041e02:	e000      	b.n	8041e06 <HAL_RCCEx_PeriphCLKConfig+0x3ea>
        break;
 8041e04:	bf00      	nop
    }

    if (ret == HAL_OK)
 8041e06:	7ffb      	ldrb	r3, [r7, #31]
 8041e08:	2b00      	cmp	r3, #0
 8041e0a:	d10b      	bne.n	8041e24 <HAL_RCCEx_PeriphCLKConfig+0x408>
    {
      /* Set the source of FDCAN kernel clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8041e0c:	4b4a      	ldr	r3, [pc, #296]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e0e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041e12:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 8041e16:	687b      	ldr	r3, [r7, #4]
 8041e18:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8041e1a:	4947      	ldr	r1, [pc, #284]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e1c:	4313      	orrs	r3, r2
 8041e1e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8041e22:	e001      	b.n	8041e28 <HAL_RCCEx_PeriphCLKConfig+0x40c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8041e24:	7ffb      	ldrb	r3, [r7, #31]
 8041e26:	77bb      	strb	r3, [r7, #30]
    }
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8041e28:	687b      	ldr	r3, [r7, #4]
 8041e2a:	681b      	ldr	r3, [r3, #0]
 8041e2c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8041e30:	2b00      	cmp	r3, #0
 8041e32:	d00a      	beq.n	8041e4a <HAL_RCCEx_PeriphCLKConfig+0x42e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8041e34:	4b40      	ldr	r3, [pc, #256]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e36:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041e3a:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8041e3e:	687b      	ldr	r3, [r7, #4]
 8041e40:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8041e42:	493d      	ldr	r1, [pc, #244]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e44:	4313      	orrs	r3, r2
 8041e46:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8041e4a:	687b      	ldr	r3, [r7, #4]
 8041e4c:	681b      	ldr	r3, [r3, #0]
 8041e4e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8041e52:	2b00      	cmp	r3, #0
 8041e54:	d00a      	beq.n	8041e6c <HAL_RCCEx_PeriphCLKConfig+0x450>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8041e56:	4b38      	ldr	r3, [pc, #224]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e58:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041e5c:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 8041e60:	687b      	ldr	r3, [r7, #4]
 8041e62:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8041e64:	4934      	ldr	r1, [pc, #208]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e66:	4313      	orrs	r3, r2
 8041e68:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8041e6c:	687b      	ldr	r3, [r7, #4]
 8041e6e:	681b      	ldr	r3, [r3, #0]
 8041e70:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8041e74:	2b00      	cmp	r3, #0
 8041e76:	d00a      	beq.n	8041e8e <HAL_RCCEx_PeriphCLKConfig+0x472>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8041e78:	4b2f      	ldr	r3, [pc, #188]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e7a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041e7e:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8041e82:	687b      	ldr	r3, [r7, #4]
 8041e84:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8041e86:	492c      	ldr	r1, [pc, #176]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e88:	4313      	orrs	r3, r2
 8041e8a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  }

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8041e8e:	687b      	ldr	r3, [r7, #4]
 8041e90:	681b      	ldr	r3, [r3, #0]
 8041e92:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8041e96:	2b00      	cmp	r3, #0
 8041e98:	d00a      	beq.n	8041eb0 <HAL_RCCEx_PeriphCLKConfig+0x494>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8041e9a:	4b27      	ldr	r3, [pc, #156]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041e9c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8041ea0:	f023 0203 	bic.w	r2, r3, #3
 8041ea4:	687b      	ldr	r3, [r7, #4]
 8041ea6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8041ea8:	4923      	ldr	r1, [pc, #140]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041eaa:	4313      	orrs	r3, r2
 8041eac:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  }

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8041eb0:	687b      	ldr	r3, [r7, #4]
 8041eb2:	681b      	ldr	r3, [r3, #0]
 8041eb4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8041eb8:	2b00      	cmp	r3, #0
 8041eba:	d028      	beq.n	8041f0e <HAL_RCCEx_PeriphCLKConfig+0x4f2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));

    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8041ebc:	4b1e      	ldr	r3, [pc, #120]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041ebe:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041ec2:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8041ec6:	687b      	ldr	r3, [r7, #4]
 8041ec8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8041eca:	491b      	ldr	r1, [pc, #108]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041ecc:	4313      	orrs	r3, r2
 8041ece:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8041ed2:	687b      	ldr	r3, [r7, #4]
 8041ed4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8041ed6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8041eda:	d106      	bne.n	8041eea <HAL_RCCEx_PeriphCLKConfig+0x4ce>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8041edc:	4b16      	ldr	r3, [pc, #88]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041ede:	68db      	ldr	r3, [r3, #12]
 8041ee0:	4a15      	ldr	r2, [pc, #84]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041ee2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8041ee6:	60d3      	str	r3, [r2, #12]
 8041ee8:	e011      	b.n	8041f0e <HAL_RCCEx_PeriphCLKConfig+0x4f2>
    }
    else
    {
      if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8041eea:	687b      	ldr	r3, [r7, #4]
 8041eec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8041eee:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8041ef2:	d10c      	bne.n	8041f0e <HAL_RCCEx_PeriphCLKConfig+0x4f2>
      {
        /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8041ef4:	687b      	ldr	r3, [r7, #4]
 8041ef6:	3304      	adds	r3, #4
 8041ef8:	2101      	movs	r1, #1
 8041efa:	4618      	mov	r0, r3
 8041efc:	f000 f8f8 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8041f00:	4603      	mov	r3, r0
 8041f02:	77fb      	strb	r3, [r7, #31]

        if (ret != HAL_OK)
 8041f04:	7ffb      	ldrb	r3, [r7, #31]
 8041f06:	2b00      	cmp	r3, #0
 8041f08:	d001      	beq.n	8041f0e <HAL_RCCEx_PeriphCLKConfig+0x4f2>
        {
          /* set overall return value */
          status = ret;
 8041f0a:	7ffb      	ldrb	r3, [r7, #31]
 8041f0c:	77bb      	strb	r3, [r7, #30]
  }

#endif /* USB */

  /*-------------------------- SDMMC1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8041f0e:	687b      	ldr	r3, [r7, #4]
 8041f10:	681b      	ldr	r3, [r3, #0]
 8041f12:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8041f16:	2b00      	cmp	r3, #0
 8041f18:	d04d      	beq.n	8041fb6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8041f1a:	687b      	ldr	r3, [r7, #4]
 8041f1c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8041f1e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8041f22:	d10b      	bne.n	8041f3c <HAL_RCCEx_PeriphCLKConfig+0x520>
 8041f24:	4b04      	ldr	r3, [pc, #16]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041f26:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8041f2a:	4a03      	ldr	r2, [pc, #12]	; (8041f38 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8041f2c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8041f30:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8041f34:	e015      	b.n	8041f62 <HAL_RCCEx_PeriphCLKConfig+0x546>
 8041f36:	bf00      	nop
 8041f38:	40021000 	.word	0x40021000
 8041f3c:	4b6b      	ldr	r3, [pc, #428]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041f3e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041f42:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8041f46:	687b      	ldr	r3, [r7, #4]
 8041f48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8041f4a:	4968      	ldr	r1, [pc, #416]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041f4c:	4313      	orrs	r3, r2
 8041f4e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
 8041f52:	4b66      	ldr	r3, [pc, #408]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041f54:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8041f58:	4a64      	ldr	r2, [pc, #400]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041f5a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8041f5e:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8041f62:	687b      	ldr	r3, [r7, #4]
 8041f64:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8041f66:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8041f6a:	d10d      	bne.n	8041f88 <HAL_RCCEx_PeriphCLKConfig+0x56c>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8041f6c:	687b      	ldr	r3, [r7, #4]
 8041f6e:	3304      	adds	r3, #4
 8041f70:	2101      	movs	r1, #1
 8041f72:	4618      	mov	r0, r3
 8041f74:	f000 f8bc 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8041f78:	4603      	mov	r3, r0
 8041f7a:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 8041f7c:	7ffb      	ldrb	r3, [r7, #31]
 8041f7e:	2b00      	cmp	r3, #0
 8041f80:	d019      	beq.n	8041fb6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
      {
        /* set overall return value */
        status = ret;
 8041f82:	7ffb      	ldrb	r3, [r7, #31]
 8041f84:	77bb      	strb	r3, [r7, #30]
 8041f86:	e016      	b.n	8041fb6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
      }
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
 8041f88:	687b      	ldr	r3, [r7, #4]
 8041f8a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8041f8c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8041f90:	d106      	bne.n	8041fa0 <HAL_RCCEx_PeriphCLKConfig+0x584>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8041f92:	4b56      	ldr	r3, [pc, #344]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041f94:	68db      	ldr	r3, [r3, #12]
 8041f96:	4a55      	ldr	r2, [pc, #340]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041f98:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8041f9c:	60d3      	str	r3, [r2, #12]
 8041f9e:	e00a      	b.n	8041fb6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLP)
 8041fa0:	687b      	ldr	r3, [r7, #4]
 8041fa2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8041fa4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8041fa8:	d105      	bne.n	8041fb6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
    {
      /* Enable PLLSAI3CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8041faa:	4b50      	ldr	r3, [pc, #320]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041fac:	68db      	ldr	r3, [r3, #12]
 8041fae:	4a4f      	ldr	r2, [pc, #316]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041fb0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8041fb4:	60d3      	str	r3, [r2, #12]
      /* Nothing to do */
    }
  }

  /*-------------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8041fb6:	687b      	ldr	r3, [r7, #4]
 8041fb8:	681b      	ldr	r3, [r3, #0]
 8041fba:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8041fbe:	2b00      	cmp	r3, #0
 8041fc0:	d028      	beq.n	8042014 <HAL_RCCEx_PeriphCLKConfig+0x5f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));

    /* Configure the RNG clock source */
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8041fc2:	4b4a      	ldr	r3, [pc, #296]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041fc4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8041fc8:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8041fcc:	687b      	ldr	r3, [r7, #4]
 8041fce:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8041fd0:	4946      	ldr	r1, [pc, #280]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041fd2:	4313      	orrs	r3, r2
 8041fd4:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8041fd8:	687b      	ldr	r3, [r7, #4]
 8041fda:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8041fdc:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8041fe0:	d106      	bne.n	8041ff0 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8041fe2:	4b42      	ldr	r3, [pc, #264]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041fe4:	68db      	ldr	r3, [r3, #12]
 8041fe6:	4a41      	ldr	r2, [pc, #260]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8041fe8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8041fec:	60d3      	str	r3, [r2, #12]
 8041fee:	e011      	b.n	8042014 <HAL_RCCEx_PeriphCLKConfig+0x5f8>
    }
    else if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8041ff0:	687b      	ldr	r3, [r7, #4]
 8041ff2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8041ff4:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8041ff8:	d10c      	bne.n	8042014 <HAL_RCCEx_PeriphCLKConfig+0x5f8>
    {
      /* PLLSAI1 input clock, parameters M, N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8041ffa:	687b      	ldr	r3, [r7, #4]
 8041ffc:	3304      	adds	r3, #4
 8041ffe:	2101      	movs	r1, #1
 8042000:	4618      	mov	r0, r3
 8042002:	f000 f875 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8042006:	4603      	mov	r3, r0
 8042008:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 804200a:	7ffb      	ldrb	r3, [r7, #31]
 804200c:	2b00      	cmp	r3, #0
 804200e:	d001      	beq.n	8042014 <HAL_RCCEx_PeriphCLKConfig+0x5f8>
      {
        /* set overall return value */
        status = ret;
 8042010:	7ffb      	ldrb	r3, [r7, #31]
 8042012:	77bb      	strb	r3, [r7, #30]
      /* Nothing to do */
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8042014:	687b      	ldr	r3, [r7, #4]
 8042016:	681b      	ldr	r3, [r3, #0]
 8042018:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 804201c:	2b00      	cmp	r3, #0
 804201e:	d01e      	beq.n	804205e <HAL_RCCEx_PeriphCLKConfig+0x642>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8042020:	4b32      	ldr	r3, [pc, #200]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8042022:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8042026:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 804202a:	687b      	ldr	r3, [r7, #4]
 804202c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8042030:	492e      	ldr	r1, [pc, #184]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8042032:	4313      	orrs	r3, r2
 8042034:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8042038:	687b      	ldr	r3, [r7, #4]
 804203a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 804203e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8042042:	d10c      	bne.n	804205e <HAL_RCCEx_PeriphCLKConfig+0x642>
    {
      /* PLLSAI1 input clock, parameters M, N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8042044:	687b      	ldr	r3, [r7, #4]
 8042046:	3304      	adds	r3, #4
 8042048:	2102      	movs	r1, #2
 804204a:	4618      	mov	r0, r3
 804204c:	f000 f850 	bl	80420f0 <RCCEx_PLLSAI1_Config>
 8042050:	4603      	mov	r3, r0
 8042052:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 8042054:	7ffb      	ldrb	r3, [r7, #31]
 8042056:	2b00      	cmp	r3, #0
 8042058:	d001      	beq.n	804205e <HAL_RCCEx_PeriphCLKConfig+0x642>
      {
        /* set overall return value */
        status = ret;
 804205a:	7ffb      	ldrb	r3, [r7, #31]
 804205c:	77bb      	strb	r3, [r7, #30]
      }
    }
  }

  /*-------------------------- DFSDM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 804205e:	687b      	ldr	r3, [r7, #4]
 8042060:	681b      	ldr	r3, [r3, #0]
 8042062:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8042066:	2b00      	cmp	r3, #0
 8042068:	d00b      	beq.n	8042082 <HAL_RCCEx_PeriphCLKConfig+0x666>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 804206a:	4b20      	ldr	r3, [pc, #128]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 804206c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8042070:	f023 0204 	bic.w	r2, r3, #4
 8042074:	687b      	ldr	r3, [r7, #4]
 8042076:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 804207a:	491c      	ldr	r1, [pc, #112]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 804207c:	4313      	orrs	r3, r2
 804207e:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  }

  /*-------------------------- DFSDM1 audio clock source configuration -------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 8042082:	687b      	ldr	r3, [r7, #4]
 8042084:	681b      	ldr	r3, [r3, #0]
 8042086:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 804208a:	2b00      	cmp	r3, #0
 804208c:	d00b      	beq.n	80420a6 <HAL_RCCEx_PeriphCLKConfig+0x68a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM1 interface audio clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 804208e:	4b17      	ldr	r3, [pc, #92]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 8042090:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8042094:	f023 0218 	bic.w	r2, r3, #24
 8042098:	687b      	ldr	r3, [r7, #4]
 804209a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 804209e:	4913      	ldr	r1, [pc, #76]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 80420a0:	4313      	orrs	r3, r2
 80420a2:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  }

  /*-------------------------- OctoSPIx clock source configuration ----------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 80420a6:	687b      	ldr	r3, [r7, #4]
 80420a8:	681b      	ldr	r3, [r3, #0]
 80420aa:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80420ae:	2b00      	cmp	r3, #0
 80420b0:	d017      	beq.n	80420e2 <HAL_RCCEx_PeriphCLKConfig+0x6c6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_OSPICLKSOURCE(PeriphClkInit->OspiClockSelection));

    /* Configure the OctoSPI clock source */
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 80420b2:	4b0e      	ldr	r3, [pc, #56]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 80420b4:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80420b8:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 80420bc:	687b      	ldr	r3, [r7, #4]
 80420be:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80420c2:	490a      	ldr	r1, [pc, #40]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 80420c4:	4313      	orrs	r3, r2
 80420c6:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
    
    if (PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 80420ca:	687b      	ldr	r3, [r7, #4]
 80420cc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80420d0:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 80420d4:	d105      	bne.n	80420e2 <HAL_RCCEx_PeriphCLKConfig+0x6c6>
    {
      /* Enable PLL48M1CLK output clock */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80420d6:	4b05      	ldr	r3, [pc, #20]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 80420d8:	68db      	ldr	r3, [r3, #12]
 80420da:	4a04      	ldr	r2, [pc, #16]	; (80420ec <HAL_RCCEx_PeriphCLKConfig+0x6d0>)
 80420dc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80420e0:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
 80420e2:	7fbb      	ldrb	r3, [r7, #30]
}
 80420e4:	4618      	mov	r0, r3
 80420e6:	3720      	adds	r7, #32
 80420e8:	46bd      	mov	sp, r7
 80420ea:	bd80      	pop	{r7, pc}
 80420ec:	40021000 	.word	0x40021000

080420f0 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *pPllSai1, uint32_t Divider)
{
 80420f0:	b580      	push	{r7, lr}
 80420f2:	b084      	sub	sp, #16
 80420f4:	af00      	add	r7, sp, #0
 80420f6:	6078      	str	r0, [r7, #4]
 80420f8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80420fa:	2300      	movs	r3, #0
 80420fc:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLSAI1M_VALUE(pPllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(pPllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(pPllSai1->PLLSAI1ClockOut));

  /* Check PLLSAI1 clock source availability */
  switch (pPllSai1->PLLSAI1Source)
 80420fe:	687b      	ldr	r3, [r7, #4]
 8042100:	681b      	ldr	r3, [r3, #0]
 8042102:	2b02      	cmp	r3, #2
 8042104:	d00c      	beq.n	8042120 <RCCEx_PLLSAI1_Config+0x30>
 8042106:	2b03      	cmp	r3, #3
 8042108:	d013      	beq.n	8042132 <RCCEx_PLLSAI1_Config+0x42>
 804210a:	2b01      	cmp	r3, #1
 804210c:	d11a      	bne.n	8042144 <RCCEx_PLLSAI1_Config+0x54>
  {
    case RCC_PLLSOURCE_MSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 804210e:	4b5d      	ldr	r3, [pc, #372]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042110:	681b      	ldr	r3, [r3, #0]
 8042112:	f003 0302 	and.w	r3, r3, #2
 8042116:	2b00      	cmp	r3, #0
 8042118:	d117      	bne.n	804214a <RCCEx_PLLSAI1_Config+0x5a>
      {
        status = HAL_ERROR;
 804211a:	2301      	movs	r3, #1
 804211c:	73fb      	strb	r3, [r7, #15]
      }
      break;
 804211e:	e014      	b.n	804214a <RCCEx_PLLSAI1_Config+0x5a>
    case RCC_PLLSOURCE_HSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8042120:	4b58      	ldr	r3, [pc, #352]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042122:	681b      	ldr	r3, [r3, #0]
 8042124:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8042128:	2b00      	cmp	r3, #0
 804212a:	d110      	bne.n	804214e <RCCEx_PLLSAI1_Config+0x5e>
      {
        status = HAL_ERROR;
 804212c:	2301      	movs	r3, #1
 804212e:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8042130:	e00d      	b.n	804214e <RCCEx_PLLSAI1_Config+0x5e>
    case RCC_PLLSOURCE_HSE:
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 8042132:	4b54      	ldr	r3, [pc, #336]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042134:	681b      	ldr	r3, [r3, #0]
 8042136:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 804213a:	2b00      	cmp	r3, #0
 804213c:	d109      	bne.n	8042152 <RCCEx_PLLSAI1_Config+0x62>
      {
        status = HAL_ERROR;
 804213e:	2301      	movs	r3, #1
 8042140:	73fb      	strb	r3, [r7, #15]
      }
      break;
 8042142:	e006      	b.n	8042152 <RCCEx_PLLSAI1_Config+0x62>
    default:
      status = HAL_ERROR;
 8042144:	2301      	movs	r3, #1
 8042146:	73fb      	strb	r3, [r7, #15]
      break;
 8042148:	e004      	b.n	8042154 <RCCEx_PLLSAI1_Config+0x64>
      break;
 804214a:	bf00      	nop
 804214c:	e002      	b.n	8042154 <RCCEx_PLLSAI1_Config+0x64>
      break;
 804214e:	bf00      	nop
 8042150:	e000      	b.n	8042154 <RCCEx_PLLSAI1_Config+0x64>
      break;
 8042152:	bf00      	nop
  }

  if (status == HAL_OK)
 8042154:	7bfb      	ldrb	r3, [r7, #15]
 8042156:	2b00      	cmp	r3, #0
 8042158:	f040 808f 	bne.w	804227a <RCCEx_PLLSAI1_Config+0x18a>
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 804215c:	4b49      	ldr	r3, [pc, #292]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 804215e:	681b      	ldr	r3, [r3, #0]
 8042160:	4a48      	ldr	r2, [pc, #288]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042162:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8042166:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8042168:	f7fe faaa 	bl	80406c0 <HAL_GetTick>
 804216c:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready to be updated */
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 804216e:	e009      	b.n	8042184 <RCCEx_PLLSAI1_Config+0x94>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8042170:	f7fe faa6 	bl	80406c0 <HAL_GetTick>
 8042174:	4602      	mov	r2, r0
 8042176:	68bb      	ldr	r3, [r7, #8]
 8042178:	1ad3      	subs	r3, r2, r3
 804217a:	2b02      	cmp	r3, #2
 804217c:	d902      	bls.n	8042184 <RCCEx_PLLSAI1_Config+0x94>
      {
        status = HAL_TIMEOUT;
 804217e:	2303      	movs	r3, #3
 8042180:	73fb      	strb	r3, [r7, #15]
        break;
 8042182:	e005      	b.n	8042190 <RCCEx_PLLSAI1_Config+0xa0>
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8042184:	4b3f      	ldr	r3, [pc, #252]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042186:	681b      	ldr	r3, [r3, #0]
 8042188:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 804218c:	2b00      	cmp	r3, #0
 804218e:	d1ef      	bne.n	8042170 <RCCEx_PLLSAI1_Config+0x80>
      }
    }

    if (status == HAL_OK)
 8042190:	7bfb      	ldrb	r3, [r7, #15]
 8042192:	2b00      	cmp	r3, #0
 8042194:	d171      	bne.n	804227a <RCCEx_PLLSAI1_Config+0x18a>
    {
      if (Divider == DIVIDER_P_UPDATE)
 8042196:	683b      	ldr	r3, [r7, #0]
 8042198:	2b00      	cmp	r3, #0
 804219a:	d116      	bne.n	80421ca <RCCEx_PLLSAI1_Config+0xda>
      {
        assert_param(IS_RCC_PLLSAI1P_VALUE(pPllSai1->PLLSAI1P));

        /* Configure the PLLSAI1 Division factor M, P and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 804219c:	4b39      	ldr	r3, [pc, #228]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 804219e:	691a      	ldr	r2, [r3, #16]
 80421a0:	4b39      	ldr	r3, [pc, #228]	; (8042288 <RCCEx_PLLSAI1_Config+0x198>)
 80421a2:	4013      	ands	r3, r2
 80421a4:	687a      	ldr	r2, [r7, #4]
 80421a6:	6892      	ldr	r2, [r2, #8]
 80421a8:	0211      	lsls	r1, r2, #8
 80421aa:	687a      	ldr	r2, [r7, #4]
 80421ac:	68d2      	ldr	r2, [r2, #12]
 80421ae:	06d2      	lsls	r2, r2, #27
 80421b0:	4311      	orrs	r1, r2
 80421b2:	687a      	ldr	r2, [r7, #4]
 80421b4:	6852      	ldr	r2, [r2, #4]
 80421b6:	3a01      	subs	r2, #1
 80421b8:	0112      	lsls	r2, r2, #4
 80421ba:	4311      	orrs	r1, r2
 80421bc:	687a      	ldr	r2, [r7, #4]
 80421be:	6812      	ldr	r2, [r2, #0]
 80421c0:	430a      	orrs	r2, r1
 80421c2:	4930      	ldr	r1, [pc, #192]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 80421c4:	4313      	orrs	r3, r2
 80421c6:	610b      	str	r3, [r1, #16]
 80421c8:	e033      	b.n	8042232 <RCCEx_PLLSAI1_Config+0x142>
                   (pPllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
                   (pPllSai1->PLLSAI1P << RCC_PLLSAI1CFGR_PLLSAI1PDIV_Pos) |
                   ((pPllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos) |
                   pPllSai1->PLLSAI1Source);
      }
      else if (Divider == DIVIDER_Q_UPDATE)
 80421ca:	683b      	ldr	r3, [r7, #0]
 80421cc:	2b01      	cmp	r3, #1
 80421ce:	d118      	bne.n	8042202 <RCCEx_PLLSAI1_Config+0x112>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(pPllSai1->PLLSAI1Q));

        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80421d0:	4b2c      	ldr	r3, [pc, #176]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 80421d2:	691a      	ldr	r2, [r3, #16]
 80421d4:	4b2d      	ldr	r3, [pc, #180]	; (804228c <RCCEx_PLLSAI1_Config+0x19c>)
 80421d6:	4013      	ands	r3, r2
 80421d8:	687a      	ldr	r2, [r7, #4]
 80421da:	6892      	ldr	r2, [r2, #8]
 80421dc:	0211      	lsls	r1, r2, #8
 80421de:	687a      	ldr	r2, [r7, #4]
 80421e0:	6912      	ldr	r2, [r2, #16]
 80421e2:	0852      	lsrs	r2, r2, #1
 80421e4:	3a01      	subs	r2, #1
 80421e6:	0552      	lsls	r2, r2, #21
 80421e8:	4311      	orrs	r1, r2
 80421ea:	687a      	ldr	r2, [r7, #4]
 80421ec:	6852      	ldr	r2, [r2, #4]
 80421ee:	3a01      	subs	r2, #1
 80421f0:	0112      	lsls	r2, r2, #4
 80421f2:	4311      	orrs	r1, r2
 80421f4:	687a      	ldr	r2, [r7, #4]
 80421f6:	6812      	ldr	r2, [r2, #0]
 80421f8:	430a      	orrs	r2, r1
 80421fa:	4922      	ldr	r1, [pc, #136]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 80421fc:	4313      	orrs	r3, r2
 80421fe:	610b      	str	r3, [r1, #16]
 8042200:	e017      	b.n	8042232 <RCCEx_PLLSAI1_Config+0x142>
      else
      {
        assert_param(IS_RCC_PLLSAI1R_VALUE(pPllSai1->PLLSAI1R));

        /* Configure the PLLSAI1 Division factor M, R and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8042202:	4b20      	ldr	r3, [pc, #128]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042204:	691a      	ldr	r2, [r3, #16]
 8042206:	4b22      	ldr	r3, [pc, #136]	; (8042290 <RCCEx_PLLSAI1_Config+0x1a0>)
 8042208:	4013      	ands	r3, r2
 804220a:	687a      	ldr	r2, [r7, #4]
 804220c:	6892      	ldr	r2, [r2, #8]
 804220e:	0211      	lsls	r1, r2, #8
 8042210:	687a      	ldr	r2, [r7, #4]
 8042212:	6952      	ldr	r2, [r2, #20]
 8042214:	0852      	lsrs	r2, r2, #1
 8042216:	3a01      	subs	r2, #1
 8042218:	0652      	lsls	r2, r2, #25
 804221a:	4311      	orrs	r1, r2
 804221c:	687a      	ldr	r2, [r7, #4]
 804221e:	6852      	ldr	r2, [r2, #4]
 8042220:	3a01      	subs	r2, #1
 8042222:	0112      	lsls	r2, r2, #4
 8042224:	4311      	orrs	r1, r2
 8042226:	687a      	ldr	r2, [r7, #4]
 8042228:	6812      	ldr	r2, [r2, #0]
 804222a:	430a      	orrs	r2, r1
 804222c:	4915      	ldr	r1, [pc, #84]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 804222e:	4313      	orrs	r3, r2
 8042230:	610b      	str	r3, [r1, #16]
                   ((pPllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos) |
                   pPllSai1->PLLSAI1Source);
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8042232:	4b14      	ldr	r3, [pc, #80]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042234:	681b      	ldr	r3, [r3, #0]
 8042236:	4a13      	ldr	r2, [pc, #76]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042238:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 804223c:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 804223e:	f7fe fa3f 	bl	80406c0 <HAL_GetTick>
 8042242:	60b8      	str	r0, [r7, #8]

      /* Wait till PLLSAI1 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8042244:	e009      	b.n	804225a <RCCEx_PLLSAI1_Config+0x16a>
      {
        if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8042246:	f7fe fa3b 	bl	80406c0 <HAL_GetTick>
 804224a:	4602      	mov	r2, r0
 804224c:	68bb      	ldr	r3, [r7, #8]
 804224e:	1ad3      	subs	r3, r2, r3
 8042250:	2b02      	cmp	r3, #2
 8042252:	d902      	bls.n	804225a <RCCEx_PLLSAI1_Config+0x16a>
        {
          status = HAL_TIMEOUT;
 8042254:	2303      	movs	r3, #3
 8042256:	73fb      	strb	r3, [r7, #15]
          break;
 8042258:	e005      	b.n	8042266 <RCCEx_PLLSAI1_Config+0x176>
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 804225a:	4b0a      	ldr	r3, [pc, #40]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 804225c:	681b      	ldr	r3, [r3, #0]
 804225e:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8042262:	2b00      	cmp	r3, #0
 8042264:	d0ef      	beq.n	8042246 <RCCEx_PLLSAI1_Config+0x156>
        }
      }

      if (status == HAL_OK)
 8042266:	7bfb      	ldrb	r3, [r7, #15]
 8042268:	2b00      	cmp	r3, #0
 804226a:	d106      	bne.n	804227a <RCCEx_PLLSAI1_Config+0x18a>
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(pPllSai1->PLLSAI1ClockOut);
 804226c:	4b05      	ldr	r3, [pc, #20]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 804226e:	691a      	ldr	r2, [r3, #16]
 8042270:	687b      	ldr	r3, [r7, #4]
 8042272:	699b      	ldr	r3, [r3, #24]
 8042274:	4903      	ldr	r1, [pc, #12]	; (8042284 <RCCEx_PLLSAI1_Config+0x194>)
 8042276:	4313      	orrs	r3, r2
 8042278:	610b      	str	r3, [r1, #16]
      }
    }
  }

  return status;
 804227a:	7bfb      	ldrb	r3, [r7, #15]
}
 804227c:	4618      	mov	r0, r3
 804227e:	3710      	adds	r7, #16
 8042280:	46bd      	mov	sp, r7
 8042282:	bd80      	pop	{r7, pc}
 8042284:	40021000 	.word	0x40021000
 8042288:	07ff800c 	.word	0x07ff800c
 804228c:	ff9f800c 	.word	0xff9f800c
 8042290:	f9ff800c 	.word	0xf9ff800c

08042294 <RCCEx_PLLSAI2_Config>:
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *pPllSai2, uint32_t Divider)
{
 8042294:	b580      	push	{r7, lr}
 8042296:	b084      	sub	sp, #16
 8042298:	af00      	add	r7, sp, #0
 804229a:	6078      	str	r0, [r7, #4]
 804229c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 804229e:	2300      	movs	r3, #0
 80422a0:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLSAI2M_VALUE(pPllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(pPllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(pPllSai2->PLLSAI2ClockOut));

  /* Check PLLSAI2 clock source availability */
  switch (pPllSai2->PLLSAI2Source)
 80422a2:	687b      	ldr	r3, [r7, #4]
 80422a4:	681b      	ldr	r3, [r3, #0]
 80422a6:	2b02      	cmp	r3, #2
 80422a8:	d00c      	beq.n	80422c4 <RCCEx_PLLSAI2_Config+0x30>
 80422aa:	2b03      	cmp	r3, #3
 80422ac:	d013      	beq.n	80422d6 <RCCEx_PLLSAI2_Config+0x42>
 80422ae:	2b01      	cmp	r3, #1
 80422b0:	d11a      	bne.n	80422e8 <RCCEx_PLLSAI2_Config+0x54>
  {
    case RCC_PLLSOURCE_MSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 80422b2:	4b42      	ldr	r3, [pc, #264]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 80422b4:	681b      	ldr	r3, [r3, #0]
 80422b6:	f003 0302 	and.w	r3, r3, #2
 80422ba:	2b00      	cmp	r3, #0
 80422bc:	d117      	bne.n	80422ee <RCCEx_PLLSAI2_Config+0x5a>
      {
        status = HAL_ERROR;
 80422be:	2301      	movs	r3, #1
 80422c0:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80422c2:	e014      	b.n	80422ee <RCCEx_PLLSAI2_Config+0x5a>
    case RCC_PLLSOURCE_HSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80422c4:	4b3d      	ldr	r3, [pc, #244]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 80422c6:	681b      	ldr	r3, [r3, #0]
 80422c8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80422cc:	2b00      	cmp	r3, #0
 80422ce:	d110      	bne.n	80422f2 <RCCEx_PLLSAI2_Config+0x5e>
      {
        status = HAL_ERROR;
 80422d0:	2301      	movs	r3, #1
 80422d2:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80422d4:	e00d      	b.n	80422f2 <RCCEx_PLLSAI2_Config+0x5e>
    case RCC_PLLSOURCE_HSE:
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 80422d6:	4b39      	ldr	r3, [pc, #228]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 80422d8:	681b      	ldr	r3, [r3, #0]
 80422da:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 80422de:	2b00      	cmp	r3, #0
 80422e0:	d109      	bne.n	80422f6 <RCCEx_PLLSAI2_Config+0x62>
      {
        status = HAL_ERROR;
 80422e2:	2301      	movs	r3, #1
 80422e4:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80422e6:	e006      	b.n	80422f6 <RCCEx_PLLSAI2_Config+0x62>
    default:
      status = HAL_ERROR;
 80422e8:	2301      	movs	r3, #1
 80422ea:	73fb      	strb	r3, [r7, #15]
      break;
 80422ec:	e004      	b.n	80422f8 <RCCEx_PLLSAI2_Config+0x64>
      break;
 80422ee:	bf00      	nop
 80422f0:	e002      	b.n	80422f8 <RCCEx_PLLSAI2_Config+0x64>
      break;
 80422f2:	bf00      	nop
 80422f4:	e000      	b.n	80422f8 <RCCEx_PLLSAI2_Config+0x64>
      break;
 80422f6:	bf00      	nop
  }

  if (status == HAL_OK)
 80422f8:	7bfb      	ldrb	r3, [r7, #15]
 80422fa:	2b00      	cmp	r3, #0
 80422fc:	d159      	bne.n	80423b2 <RCCEx_PLLSAI2_Config+0x11e>
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 80422fe:	4b2f      	ldr	r3, [pc, #188]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042300:	681b      	ldr	r3, [r3, #0]
 8042302:	4a2e      	ldr	r2, [pc, #184]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042304:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8042308:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 804230a:	f7fe f9d9 	bl	80406c0 <HAL_GetTick>
 804230e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI2 is ready to be updated */
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8042310:	e009      	b.n	8042326 <RCCEx_PLLSAI2_Config+0x92>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8042312:	f7fe f9d5 	bl	80406c0 <HAL_GetTick>
 8042316:	4602      	mov	r2, r0
 8042318:	68bb      	ldr	r3, [r7, #8]
 804231a:	1ad3      	subs	r3, r2, r3
 804231c:	2b02      	cmp	r3, #2
 804231e:	d902      	bls.n	8042326 <RCCEx_PLLSAI2_Config+0x92>
      {
        status = HAL_TIMEOUT;
 8042320:	2303      	movs	r3, #3
 8042322:	73fb      	strb	r3, [r7, #15]
        break;
 8042324:	e005      	b.n	8042332 <RCCEx_PLLSAI2_Config+0x9e>
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8042326:	4b25      	ldr	r3, [pc, #148]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042328:	681b      	ldr	r3, [r3, #0]
 804232a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 804232e:	2b00      	cmp	r3, #0
 8042330:	d1ef      	bne.n	8042312 <RCCEx_PLLSAI2_Config+0x7e>
      }
    }

    if (status == HAL_OK)
 8042332:	7bfb      	ldrb	r3, [r7, #15]
 8042334:	2b00      	cmp	r3, #0
 8042336:	d13c      	bne.n	80423b2 <RCCEx_PLLSAI2_Config+0x11e>
    {
      if (Divider == DIVIDER_P_UPDATE)
 8042338:	683b      	ldr	r3, [r7, #0]
 804233a:	2b00      	cmp	r3, #0
 804233c:	d115      	bne.n	804236a <RCCEx_PLLSAI2_Config+0xd6>
      {
        assert_param(IS_RCC_PLLSAI2P_VALUE(pPllSai2->PLLSAI2P));

        /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI2CFGR,
 804233e:	4b1f      	ldr	r3, [pc, #124]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042340:	695a      	ldr	r2, [r3, #20]
 8042342:	4b1f      	ldr	r3, [pc, #124]	; (80423c0 <RCCEx_PLLSAI2_Config+0x12c>)
 8042344:	4013      	ands	r3, r2
 8042346:	687a      	ldr	r2, [r7, #4]
 8042348:	6892      	ldr	r2, [r2, #8]
 804234a:	0211      	lsls	r1, r2, #8
 804234c:	687a      	ldr	r2, [r7, #4]
 804234e:	68d2      	ldr	r2, [r2, #12]
 8042350:	06d2      	lsls	r2, r2, #27
 8042352:	4311      	orrs	r1, r2
 8042354:	687a      	ldr	r2, [r7, #4]
 8042356:	6852      	ldr	r2, [r2, #4]
 8042358:	3a01      	subs	r2, #1
 804235a:	0112      	lsls	r2, r2, #4
 804235c:	4311      	orrs	r1, r2
 804235e:	687a      	ldr	r2, [r7, #4]
 8042360:	6812      	ldr	r2, [r2, #0]
 8042362:	430a      	orrs	r2, r1
 8042364:	4915      	ldr	r1, [pc, #84]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042366:	4313      	orrs	r3, r2
 8042368:	614b      	str	r3, [r1, #20]
                   pPllSai2->PLLSAI2Source);

      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 804236a:	4b14      	ldr	r3, [pc, #80]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 804236c:	681b      	ldr	r3, [r3, #0]
 804236e:	4a13      	ldr	r2, [pc, #76]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042370:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8042374:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8042376:	f7fe f9a3 	bl	80406c0 <HAL_GetTick>
 804237a:	60b8      	str	r0, [r7, #8]

      /* Wait till PLLSAI2 is ready */
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 804237c:	e009      	b.n	8042392 <RCCEx_PLLSAI2_Config+0xfe>
      {
        if ((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 804237e:	f7fe f99f 	bl	80406c0 <HAL_GetTick>
 8042382:	4602      	mov	r2, r0
 8042384:	68bb      	ldr	r3, [r7, #8]
 8042386:	1ad3      	subs	r3, r2, r3
 8042388:	2b02      	cmp	r3, #2
 804238a:	d902      	bls.n	8042392 <RCCEx_PLLSAI2_Config+0xfe>
        {
          status = HAL_TIMEOUT;
 804238c:	2303      	movs	r3, #3
 804238e:	73fb      	strb	r3, [r7, #15]
          break;
 8042390:	e005      	b.n	804239e <RCCEx_PLLSAI2_Config+0x10a>
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8042392:	4b0a      	ldr	r3, [pc, #40]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 8042394:	681b      	ldr	r3, [r3, #0]
 8042396:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 804239a:	2b00      	cmp	r3, #0
 804239c:	d0ef      	beq.n	804237e <RCCEx_PLLSAI2_Config+0xea>
        }
      }

      if (status == HAL_OK)
 804239e:	7bfb      	ldrb	r3, [r7, #15]
 80423a0:	2b00      	cmp	r3, #0
 80423a2:	d106      	bne.n	80423b2 <RCCEx_PLLSAI2_Config+0x11e>
      {
        /* Configure the PLLSAI2 Clock output(s) */
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(pPllSai2->PLLSAI2ClockOut);
 80423a4:	4b05      	ldr	r3, [pc, #20]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 80423a6:	695a      	ldr	r2, [r3, #20]
 80423a8:	687b      	ldr	r3, [r7, #4]
 80423aa:	691b      	ldr	r3, [r3, #16]
 80423ac:	4903      	ldr	r1, [pc, #12]	; (80423bc <RCCEx_PLLSAI2_Config+0x128>)
 80423ae:	4313      	orrs	r3, r2
 80423b0:	614b      	str	r3, [r1, #20]
      }
    }
  }

  return status;
 80423b2:	7bfb      	ldrb	r3, [r7, #15]
}
 80423b4:	4618      	mov	r0, r3
 80423b6:	3710      	adds	r7, #16
 80423b8:	46bd      	mov	sp, r7
 80423ba:	bd80      	pop	{r7, pc}
 80423bc:	40021000 	.word	0x40021000
 80423c0:	07ff800c 	.word	0x07ff800c

080423c4 <HAL_RNG_Init>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
 80423c4:	b580      	push	{r7, lr}
 80423c6:	b084      	sub	sp, #16
 80423c8:	af00      	add	r7, sp, #0
 80423ca:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 80423cc:	687b      	ldr	r3, [r7, #4]
 80423ce:	2b00      	cmp	r3, #0
 80423d0:	d101      	bne.n	80423d6 <HAL_RNG_Init+0x12>
  {
    return HAL_ERROR;
 80423d2:	2301      	movs	r3, #1
 80423d4:	e07c      	b.n	80424d0 <HAL_RNG_Init+0x10c>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 80423d6:	687b      	ldr	r3, [r7, #4]
 80423d8:	7a5b      	ldrb	r3, [r3, #9]
 80423da:	b2db      	uxtb	r3, r3
 80423dc:	2b00      	cmp	r3, #0
 80423de:	d105      	bne.n	80423ec <HAL_RNG_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 80423e0:	687b      	ldr	r3, [r7, #4]
 80423e2:	2200      	movs	r2, #0
 80423e4:	721a      	strb	r2, [r3, #8]

    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 80423e6:	6878      	ldr	r0, [r7, #4]
 80423e8:	f000 f876 	bl	80424d8 <HAL_RNG_MspInit>
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 80423ec:	687b      	ldr	r3, [r7, #4]
 80423ee:	2202      	movs	r2, #2
 80423f0:	725a      	strb	r2, [r3, #9]


  /* Disable RNG */
  __HAL_RNG_DISABLE(hrng);
 80423f2:	687b      	ldr	r3, [r7, #4]
 80423f4:	681b      	ldr	r3, [r3, #0]
 80423f6:	681a      	ldr	r2, [r3, #0]
 80423f8:	687b      	ldr	r3, [r7, #4]
 80423fa:	681b      	ldr	r3, [r3, #0]
 80423fc:	f022 0204 	bic.w	r2, r2, #4
 8042400:	601a      	str	r2, [r3, #0]

  /* Clock Error Detection Configuration when CONDRT bit is set to 1 */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, hrng->Init.ClockErrorDetection | RNG_CR_CONDRST);
 8042402:	687b      	ldr	r3, [r7, #4]
 8042404:	681b      	ldr	r3, [r3, #0]
 8042406:	681b      	ldr	r3, [r3, #0]
 8042408:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 804240c:	f023 0320 	bic.w	r3, r3, #32
 8042410:	687a      	ldr	r2, [r7, #4]
 8042412:	6852      	ldr	r2, [r2, #4]
 8042414:	431a      	orrs	r2, r3
 8042416:	687b      	ldr	r3, [r7, #4]
 8042418:	681b      	ldr	r3, [r3, #0]
 804241a:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 804241e:	601a      	str	r2, [r3, #0]

  /* Writing bits CONDRST=0*/
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 8042420:	687b      	ldr	r3, [r7, #4]
 8042422:	681b      	ldr	r3, [r3, #0]
 8042424:	681a      	ldr	r2, [r3, #0]
 8042426:	687b      	ldr	r3, [r7, #4]
 8042428:	681b      	ldr	r3, [r3, #0]
 804242a:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 804242e:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8042430:	f7fe f946 	bl	80406c0 <HAL_GetTick>
 8042434:	60f8      	str	r0, [r7, #12]

  /* Wait for conditioning reset process to be completed */
  while(HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 8042436:	e00e      	b.n	8042456 <HAL_RNG_Init+0x92>
  {
    if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 8042438:	f7fe f942 	bl	80406c0 <HAL_GetTick>
 804243c:	4602      	mov	r2, r0
 804243e:	68fb      	ldr	r3, [r7, #12]
 8042440:	1ad3      	subs	r3, r2, r3
 8042442:	2b02      	cmp	r3, #2
 8042444:	d907      	bls.n	8042456 <HAL_RNG_Init+0x92>
    {
      hrng->State = HAL_RNG_STATE_READY;
 8042446:	687b      	ldr	r3, [r7, #4]
 8042448:	2201      	movs	r2, #1
 804244a:	725a      	strb	r2, [r3, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 804244c:	687b      	ldr	r3, [r7, #4]
 804244e:	2202      	movs	r2, #2
 8042450:	60da      	str	r2, [r3, #12]
      return HAL_ERROR;
 8042452:	2301      	movs	r3, #1
 8042454:	e03c      	b.n	80424d0 <HAL_RNG_Init+0x10c>
  while(HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 8042456:	687b      	ldr	r3, [r7, #4]
 8042458:	681b      	ldr	r3, [r3, #0]
 804245a:	681b      	ldr	r3, [r3, #0]
 804245c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8042460:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8042464:	d0e8      	beq.n	8042438 <HAL_RNG_Init+0x74>
    }
  }

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 8042466:	687b      	ldr	r3, [r7, #4]
 8042468:	681b      	ldr	r3, [r3, #0]
 804246a:	681a      	ldr	r2, [r3, #0]
 804246c:	687b      	ldr	r3, [r7, #4]
 804246e:	681b      	ldr	r3, [r3, #0]
 8042470:	f042 0204 	orr.w	r2, r2, #4
 8042474:	601a      	str	r2, [r3, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 8042476:	687b      	ldr	r3, [r7, #4]
 8042478:	681b      	ldr	r3, [r3, #0]
 804247a:	685b      	ldr	r3, [r3, #4]
 804247c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8042480:	2b40      	cmp	r3, #64	; 0x40
 8042482:	d104      	bne.n	804248e <HAL_RNG_Init+0xca>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 8042484:	687b      	ldr	r3, [r7, #4]
 8042486:	2204      	movs	r2, #4
 8042488:	725a      	strb	r2, [r3, #9]
    return HAL_ERROR;
 804248a:	2301      	movs	r3, #1
 804248c:	e020      	b.n	80424d0 <HAL_RNG_Init+0x10c>
  }
  /* Get tick */
  tickstart = HAL_GetTick();
 804248e:	f7fe f917 	bl	80406c0 <HAL_GetTick>
 8042492:	60f8      	str	r0, [r7, #12]
  /* Check if data register contains valid random data */
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 8042494:	e00e      	b.n	80424b4 <HAL_RNG_Init+0xf0>
  {
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8042496:	f7fe f913 	bl	80406c0 <HAL_GetTick>
 804249a:	4602      	mov	r2, r0
 804249c:	68fb      	ldr	r3, [r7, #12]
 804249e:	1ad3      	subs	r3, r2, r3
 80424a0:	2b02      	cmp	r3, #2
 80424a2:	d907      	bls.n	80424b4 <HAL_RNG_Init+0xf0>
    {
      hrng->State = HAL_RNG_STATE_ERROR;
 80424a4:	687b      	ldr	r3, [r7, #4]
 80424a6:	2204      	movs	r2, #4
 80424a8:	725a      	strb	r2, [r3, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 80424aa:	687b      	ldr	r3, [r7, #4]
 80424ac:	2202      	movs	r2, #2
 80424ae:	60da      	str	r2, [r3, #12]
      return HAL_ERROR;
 80424b0:	2301      	movs	r3, #1
 80424b2:	e00d      	b.n	80424d0 <HAL_RNG_Init+0x10c>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 80424b4:	687b      	ldr	r3, [r7, #4]
 80424b6:	681b      	ldr	r3, [r3, #0]
 80424b8:	685b      	ldr	r3, [r3, #4]
 80424ba:	f003 0304 	and.w	r3, r3, #4
 80424be:	2b04      	cmp	r3, #4
 80424c0:	d0e9      	beq.n	8042496 <HAL_RNG_Init+0xd2>
    }
  }

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 80424c2:	687b      	ldr	r3, [r7, #4]
 80424c4:	2201      	movs	r2, #1
 80424c6:	725a      	strb	r2, [r3, #9]

  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 80424c8:	687b      	ldr	r3, [r7, #4]
 80424ca:	2200      	movs	r2, #0
 80424cc:	60da      	str	r2, [r3, #12]

  /* Return function status */
  return HAL_OK;
 80424ce:	2300      	movs	r3, #0
}
 80424d0:	4618      	mov	r0, r3
 80424d2:	3710      	adds	r7, #16
 80424d4:	46bd      	mov	sp, r7
 80424d6:	bd80      	pop	{r7, pc}

080424d8 <HAL_RNG_MspInit>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval None
  */
__weak void HAL_RNG_MspInit(RNG_HandleTypeDef *hrng)
{
 80424d8:	b480      	push	{r7}
 80424da:	b083      	sub	sp, #12
 80424dc:	af00      	add	r7, sp, #0
 80424de:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrng);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_RNG_MspInit must be implemented in the user file.
   */
}
 80424e0:	bf00      	nop
 80424e2:	370c      	adds	r7, #12
 80424e4:	46bd      	mov	sp, r7
 80424e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80424ea:	4770      	bx	lr

080424ec <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 80424ec:	b580      	push	{r7, lr}
 80424ee:	b084      	sub	sp, #16
 80424f0:	af00      	add	r7, sp, #0
 80424f2:	6078      	str	r0, [r7, #4]
 80424f4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80424f6:	2300      	movs	r3, #0
 80424f8:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hrng);
 80424fa:	687b      	ldr	r3, [r7, #4]
 80424fc:	7a1b      	ldrb	r3, [r3, #8]
 80424fe:	2b01      	cmp	r3, #1
 8042500:	d101      	bne.n	8042506 <HAL_RNG_GenerateRandomNumber+0x1a>
 8042502:	2302      	movs	r3, #2
 8042504:	e03d      	b.n	8042582 <HAL_RNG_GenerateRandomNumber+0x96>
 8042506:	687b      	ldr	r3, [r7, #4]
 8042508:	2201      	movs	r2, #1
 804250a:	721a      	strb	r2, [r3, #8]

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 804250c:	687b      	ldr	r3, [r7, #4]
 804250e:	7a5b      	ldrb	r3, [r3, #9]
 8042510:	b2db      	uxtb	r3, r3
 8042512:	2b01      	cmp	r3, #1
 8042514:	d12c      	bne.n	8042570 <HAL_RNG_GenerateRandomNumber+0x84>
  {
    /* Change RNG peripheral state */
    hrng->State = HAL_RNG_STATE_BUSY;
 8042516:	687b      	ldr	r3, [r7, #4]
 8042518:	2202      	movs	r2, #2
 804251a:	725a      	strb	r2, [r3, #9]

    /* Get tick */
    tickstart = HAL_GetTick();
 804251c:	f7fe f8d0 	bl	80406c0 <HAL_GetTick>
 8042520:	60b8      	str	r0, [r7, #8]

    /* Check if data register contains valid random data */
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8042522:	e011      	b.n	8042548 <HAL_RNG_GenerateRandomNumber+0x5c>
    {
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8042524:	f7fe f8cc 	bl	80406c0 <HAL_GetTick>
 8042528:	4602      	mov	r2, r0
 804252a:	68bb      	ldr	r3, [r7, #8]
 804252c:	1ad3      	subs	r3, r2, r3
 804252e:	2b02      	cmp	r3, #2
 8042530:	d90a      	bls.n	8042548 <HAL_RNG_GenerateRandomNumber+0x5c>
      {
        hrng->State = HAL_RNG_STATE_READY;
 8042532:	687b      	ldr	r3, [r7, #4]
 8042534:	2201      	movs	r2, #1
 8042536:	725a      	strb	r2, [r3, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8042538:	687b      	ldr	r3, [r7, #4]
 804253a:	2202      	movs	r2, #2
 804253c:	60da      	str	r2, [r3, #12]
        /* Process Unlocked */
        __HAL_UNLOCK(hrng);
 804253e:	687b      	ldr	r3, [r7, #4]
 8042540:	2200      	movs	r2, #0
 8042542:	721a      	strb	r2, [r3, #8]
        return HAL_ERROR;
 8042544:	2301      	movs	r3, #1
 8042546:	e01c      	b.n	8042582 <HAL_RNG_GenerateRandomNumber+0x96>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8042548:	687b      	ldr	r3, [r7, #4]
 804254a:	681b      	ldr	r3, [r3, #0]
 804254c:	685b      	ldr	r3, [r3, #4]
 804254e:	f003 0301 	and.w	r3, r3, #1
 8042552:	2b01      	cmp	r3, #1
 8042554:	d1e6      	bne.n	8042524 <HAL_RNG_GenerateRandomNumber+0x38>
      }
    }

    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8042556:	687b      	ldr	r3, [r7, #4]
 8042558:	681b      	ldr	r3, [r3, #0]
 804255a:	689a      	ldr	r2, [r3, #8]
 804255c:	687b      	ldr	r3, [r7, #4]
 804255e:	611a      	str	r2, [r3, #16]
    *random32bit = hrng->RandomNumber;
 8042560:	687b      	ldr	r3, [r7, #4]
 8042562:	691a      	ldr	r2, [r3, #16]
 8042564:	683b      	ldr	r3, [r7, #0]
 8042566:	601a      	str	r2, [r3, #0]

    hrng->State = HAL_RNG_STATE_READY;
 8042568:	687b      	ldr	r3, [r7, #4]
 804256a:	2201      	movs	r2, #1
 804256c:	725a      	strb	r2, [r3, #9]
 804256e:	e004      	b.n	804257a <HAL_RNG_GenerateRandomNumber+0x8e>
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 8042570:	687b      	ldr	r3, [r7, #4]
 8042572:	2204      	movs	r2, #4
 8042574:	60da      	str	r2, [r3, #12]
    status = HAL_ERROR;
 8042576:	2301      	movs	r3, #1
 8042578:	73fb      	strb	r3, [r7, #15]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 804257a:	687b      	ldr	r3, [r7, #4]
 804257c:	2200      	movs	r2, #0
 804257e:	721a      	strb	r2, [r3, #8]

  return status;
 8042580:	7bfb      	ldrb	r3, [r7, #15]
}
 8042582:	4618      	mov	r0, r3
 8042584:	3710      	adds	r7, #16
 8042586:	46bd      	mov	sp, r7
 8042588:	bd80      	pop	{r7, pc}
	...

0804258c <__libc_init_array>:
 804258c:	b570      	push	{r4, r5, r6, lr}
 804258e:	4e0d      	ldr	r6, [pc, #52]	; (80425c4 <__libc_init_array+0x38>)
 8042590:	2500      	movs	r5, #0
 8042592:	4c0d      	ldr	r4, [pc, #52]	; (80425c8 <__libc_init_array+0x3c>)
 8042594:	1ba4      	subs	r4, r4, r6
 8042596:	10a4      	asrs	r4, r4, #2
 8042598:	42a5      	cmp	r5, r4
 804259a:	d109      	bne.n	80425b0 <__libc_init_array+0x24>
 804259c:	4e0b      	ldr	r6, [pc, #44]	; (80425cc <__libc_init_array+0x40>)
 804259e:	2500      	movs	r5, #0
 80425a0:	4c0b      	ldr	r4, [pc, #44]	; (80425d0 <__libc_init_array+0x44>)
 80425a2:	f000 f81f 	bl	80425e4 <_init>
 80425a6:	1ba4      	subs	r4, r4, r6
 80425a8:	10a4      	asrs	r4, r4, #2
 80425aa:	42a5      	cmp	r5, r4
 80425ac:	d105      	bne.n	80425ba <__libc_init_array+0x2e>
 80425ae:	bd70      	pop	{r4, r5, r6, pc}
 80425b0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80425b4:	3501      	adds	r5, #1
 80425b6:	4798      	blx	r3
 80425b8:	e7ee      	b.n	8042598 <__libc_init_array+0xc>
 80425ba:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80425be:	3501      	adds	r5, #1
 80425c0:	4798      	blx	r3
 80425c2:	e7f2      	b.n	80425aa <__libc_init_array+0x1e>
 80425c4:	08042630 	.word	0x08042630
 80425c8:	08042630 	.word	0x08042630
 80425cc:	08042630 	.word	0x08042630
 80425d0:	08042634 	.word	0x08042634

080425d4 <memset>:
 80425d4:	4402      	add	r2, r0
 80425d6:	4603      	mov	r3, r0
 80425d8:	4293      	cmp	r3, r2
 80425da:	d100      	bne.n	80425de <memset+0xa>
 80425dc:	4770      	bx	lr
 80425de:	f803 1b01 	strb.w	r1, [r3], #1
 80425e2:	e7f9      	b.n	80425d8 <memset+0x4>

080425e4 <_init>:
 80425e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80425e6:	bf00      	nop
 80425e8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80425ea:	bc08      	pop	{r3}
 80425ec:	469e      	mov	lr, r3
 80425ee:	4770      	bx	lr

080425f0 <_fini>:
 80425f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80425f2:	bf00      	nop
 80425f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80425f6:	bc08      	pop	{r3}
 80425f8:	469e      	mov	lr, r3
 80425fa:	4770      	bx	lr
 80425fc:	0000      	movs	r0, r0
	...

08042600 <__SECURE_SystemCoreClockUpdate_veneer>:
 8042600:	b401      	push	{r0}
 8042602:	4802      	ldr	r0, [pc, #8]	; (804260c <__SECURE_SystemCoreClockUpdate_veneer+0xc>)
 8042604:	4684      	mov	ip, r0
 8042606:	bc01      	pop	{r0}
 8042608:	4760      	bx	ip
 804260a:	bf00      	nop
 804260c:	0c03e001 	.word	0x0c03e001

08042610 <__SECURE_GenerateRandom_veneer>:
 8042610:	b401      	push	{r0}
 8042612:	4802      	ldr	r0, [pc, #8]	; (804261c <__SECURE_GenerateRandom_veneer+0xc>)
 8042614:	4684      	mov	ip, r0
 8042616:	bc01      	pop	{r0}
 8042618:	4760      	bx	ip
 804261a:	bf00      	nop
 804261c:	0c03e019 	.word	0x0c03e019

08042620 <__SECURE_TransmitRandomUart_veneer>:
 8042620:	b401      	push	{r0}
 8042622:	4802      	ldr	r0, [pc, #8]	; (804262c <__SECURE_TransmitRandomUart_veneer+0xc>)
 8042624:	4684      	mov	ip, r0
 8042626:	bc01      	pop	{r0}
 8042628:	4760      	bx	ip
 804262a:	bf00      	nop
 804262c:	0c03e009 	.word	0x0c03e009
